import {
  big_default,
  proxy,
  proxyMap,
  ref,
  require_dayjs_min,
  require_en,
  require_relativeTime,
  require_updateLocale,
  snapshot,
  subscribe,
  subscribeKey
} from "./chunk-MPFPK2NW.js";
import {
  IEvents,
  esm_exports,
  require_cjs,
  require_cjs2,
  require_cjs3
} from "./chunk-FHDEP4DY.js";
import {
  css,
  unsafeCSS
} from "./chunk-6UCLRGWQ.js";
import {
  require_elliptic
} from "./chunk-YRHJM3VZ.js";
import {
  HashMD
} from "./chunk-4YMURMKN.js";
import {
  LruMap,
  defineFormatter,
  hexToNumber,
  numberToHex
} from "./chunk-L32OMEKI.js";
import {
  keccak_256
} from "./chunk-CMBZSXRH.js";
import {
  rotl,
  wrapConstructor
} from "./chunk-CZRW3BZV.js";
import {
  require_events
} from "./chunk-2YULO2GZ.js";
import {
  formatUnits
} from "./chunk-LCESHE4Y.js";
import {
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = {
  WC_NAME_SUFFIX: ".reown.id",
  WC_NAME_SUFFIX_LEGACY: ".wcn.id",
  BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
  PULSE_API_URL: "https://pulse.walletconnect.org",
  W3M_API_URL: "https://api.web3modal.org",
  CONNECTOR_ID: {
    WALLET_CONNECT: "walletConnect",
    INJECTED: "injected",
    WALLET_STANDARD: "announced",
    COINBASE: "coinbaseWallet",
    COINBASE_SDK: "coinbaseWalletSDK",
    SAFE: "safe",
    LEDGER: "ledger",
    OKX: "okx",
    EIP6963: "eip6963",
    AUTH: "ID_AUTH"
  },
  CONNECTOR_NAMES: {
    AUTH: "Auth"
  },
  AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
  LIMITS: {
    PENDING_TRANSACTIONS: 99
  },
  CHAIN: {
    EVM: "eip155",
    SOLANA: "solana",
    POLKADOT: "polkadot",
    BITCOIN: "bip122"
  },
  CHAIN_NAME_MAP: {
    eip155: "EVM Networks",
    solana: "Solana",
    polkadot: "Polkadot",
    bip122: "Bitcoin"
  },
  ADAPTER_TYPES: {
    BITCOIN: "bitcoin",
    SOLANA: "solana",
    WAGMI: "wagmi",
    ETHERS: "ethers",
    ETHERS5: "ethers5"
  },
  USDT_CONTRACT_ADDRESSES: [
    "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
    "0x919C1c267BC06a7039e03fcc2eF738525769109c",
    "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
    "0x55d398326f99059fF775485246999027B3197955",
    "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9"
  ],
  HTTP_STATUS_CODES: {
    SERVICE_UNAVAILABLE: 503,
    FORBIDDEN: 403
  },
  UNSUPPORTED_NETWORK_NAME: "Unknown Network"
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/DateUtil.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_en = __toESM(require_en(), 1);
var import_relativeTime = __toESM(require_relativeTime(), 1);
var import_updateLocale = __toESM(require_updateLocale(), 1);
import_dayjs.default.extend(import_relativeTime.default);
import_dayjs.default.extend(import_updateLocale.default);
var localeObject = {
  ...import_en.default,
  name: "en-web3-modal",
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%d sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
};
import_dayjs.default.locale("en-web3-modal", localeObject);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/NetworkUtil.js
var NetworkUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  parseEvmChainId(chainId) {
    return typeof chainId === "string" ? this.caipNetworkIdToNumber(chainId) : chainId;
  },
  getNetworksByNamespace(networks, namespace) {
    return networks?.filter((network) => network.chainNamespace === namespace) || [];
  },
  getFirstNetworkByNamespace(networks, namespace) {
    return this.getNetworksByNamespace(networks, namespace)[0];
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/NumberUtil.js
var NumberUtil = {
  bigNumber(value) {
    if (!value) {
      return new big_default(0);
    }
    return new big_default(value);
  },
  multiply(a2, b2) {
    if (a2 === void 0 || b2 === void 0) {
      return new big_default(0);
    }
    const aBigNumber = new big_default(a2);
    const bBigNumber = new big_default(b2);
    return aBigNumber.times(bBigNumber);
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  },
  parseLocalStringToNumber(value) {
    if (value === void 0) {
      return 0;
    }
    return parseFloat(value.replace(/,/gu, ""));
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/contracts/erc20.js
var erc20ABI = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/contracts/swap.js
var swapABI = [
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    outputs: [{ type: "bool" }]
  }
];

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/contracts/usdt.js
var usdtABI = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/ContractUtil.js
var ContractUtil = {
  getERC20Abi: (tokenAddress) => {
    if (ConstantsUtil.USDT_CONTRACT_ADDRESSES.includes(tokenAddress)) {
      return usdtABI;
    }
    return erc20ABI;
  },
  getSwapAbi: () => swapABI
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/EmitterUtil.js
var Emitter = class _Emitter {
  on(eventName, callback) {
    if (!_Emitter.eventListeners.has(eventName)) {
      _Emitter.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    _Emitter.eventListeners.get(eventName)?.add(callback);
  }
  off(eventName, callback) {
    const listeners = _Emitter.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  emit(eventName, data) {
    const listeners = _Emitter.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  clear(eventName) {
    _Emitter.eventListeners.delete(eventName);
  }
  clearAll() {
    _Emitter.eventListeners.clear();
  }
};
Emitter.eventListeners = /* @__PURE__ */ new Map();

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/ParseUtil.js
var ParseUtil = {
  validateCaipAddress(address) {
    if (address.split(":")?.length !== 3) {
      throw new Error("Invalid CAIP Address");
    }
    return address;
  },
  parseCaipAddress(caipAddress) {
    const parts = caipAddress.split(":");
    if (parts.length !== 3) {
      throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
    }
    const [chainNamespace, chainId, address] = parts;
    if (!chainNamespace || !chainId || !address) {
      throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
    }
    return {
      chainNamespace,
      chainId,
      address
    };
  },
  parseCaipNetworkId(caipNetworkId) {
    const parts = caipNetworkId.split(":");
    if (parts.length !== 2) {
      throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
    }
    const [chainNamespace, chainId] = parts;
    if (!chainNamespace || !chainId) {
      throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
    }
    return {
      chainNamespace,
      chainId
    };
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/SafeLocalStorage.js
var SafeLocalStorageKeys = {
  WALLET_ID: "@appkit/wallet_id",
  WALLET_NAME: "@appkit/wallet_name",
  SOLANA_WALLET: "@appkit/solana_wallet",
  SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
  ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
  CONNECTED_SOCIAL: "@appkit/connected_social",
  CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
  RECENT_WALLETS: "@appkit/recent_wallets",
  DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
  ACTIVE_NAMESPACE: "@appkit/active_namespace",
  CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
  CONNECTION_STATUS: "@appkit/connection_status",
  SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
  SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
  TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
  NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
  PORTFOLIO_CACHE: "@appkit/portfolio_cache",
  ENS_CACHE: "@appkit/ens_cache",
  IDENTITY_CACHE: "@appkit/identity_cache"
};
function getSafeConnectorIdKey(namespace) {
  if (!namespace) {
    throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
  }
  return `@appkit/${namespace}:connected_connector_id`;
}
var SafeLocalStorage = {
  setItem(key, value) {
    if (isSafe() && value !== void 0) {
      localStorage.setItem(key, value);
    }
  },
  getItem(key) {
    if (isSafe()) {
      return localStorage.getItem(key) || void 0;
    }
    return void 0;
  },
  removeItem(key) {
    if (isSafe()) {
      localStorage.removeItem(key);
    }
  },
  clear() {
    if (isSafe()) {
      localStorage.clear();
    }
  }
};
function isSafe() {
  return typeof window !== "undefined" && typeof localStorage !== "undefined";
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-common/dist/esm/src/utils/ThemeUtil.js
function getW3mThemeVariables(themeVariables, themeType) {
  if (themeType === "light") {
    return {
      "--w3m-accent": themeVariables?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
      "--w3m-background": "#fff"
    };
  }
  return {
    "--w3m-accent": themeVariables?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/StorageUtil.js
var StorageUtil = {
  // Cache expiry in milliseconds
  cacheExpiry: {
    portfolio: 3e4,
    nativeBalance: 3e4,
    ens: 3e5,
    identity: 3e5
  },
  isCacheExpired(timestamp, cacheExpiry) {
    return Date.now() - timestamp > cacheExpiry;
  },
  getActiveNetworkProps() {
    const namespace = StorageUtil.getActiveNamespace();
    const caipNetworkId = StorageUtil.getActiveCaipNetworkId();
    const stringChainId = caipNetworkId ? caipNetworkId.split(":")[1] : void 0;
    const chainId = stringChainId ? isNaN(Number(stringChainId)) ? stringChainId : Number(stringChainId) : void 0;
    return {
      namespace,
      caipNetworkId,
      chainId
    };
  },
  setWalletConnectDeepLink({ name, href }) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.DEEPLINK_CHOICE, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = SafeLocalStorage.getItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setActiveNamespace(namespace) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE, namespace);
    } catch {
      console.info("Unable to set active namespace");
    }
  },
  setActiveCaipNetworkId(caipNetworkId) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID, caipNetworkId);
      StorageUtil.setActiveNamespace(caipNetworkId.split(":")[0]);
    } catch {
      console.info("Unable to set active caip network id");
    }
  },
  getActiveCaipNetworkId() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to get active caip network id");
      return void 0;
    }
  },
  deleteActiveCaipNetworkId() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to delete active caip network id");
    }
  },
  deleteConnectedConnectorId(namespace) {
    try {
      const key = getSafeConnectorIdKey(namespace);
      SafeLocalStorage.removeItem(key);
    } catch {
      console.info("Unable to delete connected connector id");
    }
  },
  setAppKitRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists = recentWallets.find((w) => w.id === wallet.id);
      if (!exists) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        SafeLocalStorage.setItem(SafeLocalStorageKeys.RECENT_WALLETS, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set AppKit recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = SafeLocalStorage.getItem(SafeLocalStorageKeys.RECENT_WALLETS);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get AppKit recent");
    }
    return [];
  },
  setConnectedConnectorId(namespace, connectorId) {
    try {
      const key = getSafeConnectorIdKey(namespace);
      SafeLocalStorage.setItem(key, connectorId);
    } catch {
      console.info("Unable to set Connected Connector Id");
    }
  },
  getActiveNamespace() {
    try {
      const activeNamespace = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE);
      return activeNamespace;
    } catch {
      console.info("Unable to get active namespace");
    }
    return void 0;
  },
  getConnectedConnectorId(namespace) {
    if (!namespace) {
      return void 0;
    }
    try {
      const key = getSafeConnectorIdKey(namespace);
      return SafeLocalStorage.getItem(key);
    } catch (e) {
      console.info("Unable to get connected connector id in namespace ", namespace);
    }
    return void 0;
  },
  setConnectedSocialProvider(socialProvider) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_SOCIAL, socialProvider);
    } catch {
      console.info("Unable to set connected social provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get connected social provider");
    }
    return void 0;
  },
  deleteConnectedSocialProvider() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to delete connected social provider");
    }
  },
  getConnectedSocialUsername() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get connected social username");
    }
    return void 0;
  },
  getStoredActiveCaipNetworkId() {
    const storedCaipNetworkId = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    const networkId = storedCaipNetworkId?.split(":")?.[1];
    return networkId;
  },
  setConnectionStatus(status) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTION_STATUS, status);
    } catch {
      console.info("Unable to set connection status");
    }
  },
  getConnectionStatus() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTION_STATUS);
    } catch {
      return void 0;
    }
  },
  getConnectedNamespaces() {
    try {
      const namespaces = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES);
      if (!namespaces?.length) {
        return [];
      }
      return namespaces.split(",");
    } catch {
      return [];
    }
  },
  setConnectedNamespaces(namespaces) {
    try {
      const uniqueNamespaces = Array.from(new Set(namespaces));
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES, uniqueNamespaces.join(","));
    } catch {
      console.info("Unable to set namespaces in storage");
    }
  },
  addConnectedNamespace(namespace) {
    try {
      const namespaces = StorageUtil.getConnectedNamespaces();
      if (!namespaces.includes(namespace)) {
        namespaces.push(namespace);
        StorageUtil.setConnectedNamespaces(namespaces);
      }
    } catch {
      console.info("Unable to add connected namespace");
    }
  },
  removeConnectedNamespace(namespace) {
    try {
      const namespaces = StorageUtil.getConnectedNamespaces();
      const index = namespaces.indexOf(namespace);
      if (index > -1) {
        namespaces.splice(index, 1);
        StorageUtil.setConnectedNamespaces(namespaces);
      }
    } catch {
      console.info("Unable to remove connected namespace");
    }
  },
  getTelegramSocialProvider() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER);
    } catch {
      console.info("Unable to get telegram social provider");
      return null;
    }
  },
  setTelegramSocialProvider(socialProvider) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER, socialProvider);
    } catch {
      console.info("Unable to set telegram social provider");
    }
  },
  removeTelegramSocialProvider() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER);
    } catch {
      console.info("Unable to remove telegram social provider");
    }
  },
  getBalanceCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return cache;
  },
  removeAddressFromBalanceCache(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", caipAddress);
    }
  },
  getBalanceCacheForCaipAddress(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      const balanceCache = cache[caipAddress];
      if (balanceCache && !this.isCacheExpired(balanceCache.timestamp, this.cacheExpiry.portfolio)) {
        return balanceCache.balance;
      }
      StorageUtil.removeAddressFromBalanceCache(caipAddress);
    } catch {
      console.info("Unable to get balance cache for address", caipAddress);
    }
    return void 0;
  },
  updateBalanceCache(params) {
    try {
      const cache = StorageUtil.getBalanceCache();
      cache[params.caipAddress] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update balance cache", params);
    }
  },
  getNativeBalanceCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return cache;
  },
  removeAddressFromNativeBalanceCache(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", caipAddress);
    }
  },
  getNativeBalanceCacheForCaipAddress(caipAddress) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      const nativeBalanceCache = cache[caipAddress];
      if (nativeBalanceCache && !this.isCacheExpired(nativeBalanceCache.timestamp, this.cacheExpiry.nativeBalance)) {
        return nativeBalanceCache;
      }
      console.info("Discarding cache for address", caipAddress);
      StorageUtil.removeAddressFromBalanceCache(caipAddress);
    } catch {
      console.info("Unable to get balance cache for address", caipAddress);
    }
    return void 0;
  },
  updateNativeBalanceCache(params) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      cache[params.caipAddress] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update balance cache", params);
    }
  },
  getEnsCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.ENS_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get ens name cache");
    }
    return cache;
  },
  getEnsFromCacheForAddress(address) {
    try {
      const cache = StorageUtil.getEnsCache();
      const ensCache = cache[address];
      if (ensCache && !this.isCacheExpired(ensCache.timestamp, this.cacheExpiry.ens)) {
        return ensCache.ens;
      }
      StorageUtil.removeEnsFromCache(address);
    } catch {
      console.info("Unable to get ens name from cache", address);
    }
    return void 0;
  },
  updateEnsCache(params) {
    try {
      const cache = StorageUtil.getEnsCache();
      cache[params.address] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update ens name cache", params);
    }
  },
  removeEnsFromCache(address) {
    try {
      const cache = StorageUtil.getEnsCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify({ ...cache, [address]: void 0 }));
    } catch {
      console.info("Unable to remove ens name from cache", address);
    }
  },
  getIdentityCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.IDENTITY_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get identity cache");
    }
    return cache;
  },
  getIdentityFromCacheForAddress(address) {
    try {
      const cache = StorageUtil.getIdentityCache();
      const identityCache = cache[address];
      if (identityCache && !this.isCacheExpired(identityCache.timestamp, this.cacheExpiry.identity)) {
        return identityCache.identity;
      }
      StorageUtil.removeIdentityFromCache(address);
    } catch {
      console.info("Unable to get identity from cache", address);
    }
    return void 0;
  },
  updateIdentityCache(params) {
    try {
      const cache = StorageUtil.getIdentityCache();
      cache[params.address] = {
        identity: params.identity,
        timestamp: params.timestamp
      };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update identity cache", params);
    }
  },
  removeIdentityFromCache(address) {
    try {
      const cache = StorageUtil.getIdentityCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify({ ...cache, [address]: void 0 }));
    } catch {
      console.info("Unable to remove identity from cache", address);
    }
  },
  clearAddressCache() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.ENS_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.IDENTITY_CACHE);
    } catch {
      console.info("Unable to clear address cache");
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js
var SECURE_SITE = (
  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
  (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org"
);
var ONRAMP_PROVIDERS = [
  {
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: "",
    supportedChains: ["eip155"]
  },
  {
    label: "Meld.io",
    name: "meld",
    feeRange: "1-2%",
    url: "https://meldcrypto.com",
    supportedChains: ["eip155", "solana"]
  }
];
var ConstantsUtil2 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  FIVE_SEC_MS: 5e3,
  THREE_SEC_MS: 3e3,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  /**
   * Network name to Coinbase Pay SDK chain name map object
   * @see supported chain names on Coinbase for Pay SDK: https://github.com/coinbase/cbpay-js/blob/d4bda2c05c4d5917c8db6a05476b603546046394/src/types/onramp.ts
   */
  WC_COINBASE_PAY_SDK_CHAINS: [
    "ethereum",
    "arbitrum",
    "polygon",
    "berachain",
    "avalanche-c-chain",
    "optimism",
    "celo",
    "base"
  ],
  WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
  WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
    Ethereum: "ethereum",
    "Arbitrum One": "arbitrum",
    Polygon: "polygon",
    Berachain: "berachain",
    Avalanche: "avalanche-c-chain",
    "OP Mainnet": "optimism",
    Celo: "celo",
    Base: "base"
  },
  WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_POPULAR_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP",
    "METAL",
    "DAI",
    "CHAMP",
    "WOLF",
    "SALE",
    "BAL",
    "BUSD",
    "MUST",
    "BTCpx",
    "ROUTE",
    "HEX",
    "WELT",
    "amDAI",
    "VSQ",
    "VISION",
    "AURUM",
    "pSP",
    "SNX",
    "VC",
    "LINK",
    "CHP",
    "amUSDT",
    "SPHERE",
    "FOX",
    "GIDDY",
    "GFC",
    "OMEN",
    "OX_OLD",
    "DE",
    "WNT"
  ],
  BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
  SWAP_SUPPORTED_NETWORKS: [
    // Ethereum'
    "eip155:1",
    // Arbitrum One'
    "eip155:42161",
    // Optimism'
    "eip155:10",
    // ZKSync Era'
    "eip155:324",
    // Base'
    "eip155:8453",
    // BNB Smart Chain'
    "eip155:56",
    // Polygon'
    "eip155:137",
    // Gnosis'
    "eip155:100",
    // Avalanche'
    "eip155:43114",
    // Fantom'
    "eip155:250",
    // Klaytn'
    "eip155:8217",
    // Aurora
    "eip155:1313161554"
  ],
  NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
  ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
  ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155", "solana"],
  NATIVE_TOKEN_ADDRESS: {
    eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    solana: "So11111111111111111111111111111111111111111",
    polkadot: "0x",
    bip122: "0x"
  },
  CONVERT_SLIPPAGE_TOLERANCE: 1,
  CONNECT_LABELS: {
    MOBILE: "Open and continue in a new browser tab"
  },
  DEFAULT_FEATURES: {
    swaps: true,
    onramp: true,
    receive: true,
    send: true,
    email: true,
    emailShowWallets: true,
    socials: [
      "google",
      "x",
      "discord",
      "farcaster",
      "github",
      "apple",
      "facebook"
    ],
    connectorTypeOrder: [
      "walletConnect",
      "recent",
      "injected",
      "featured",
      "custom",
      "external",
      "recommended"
    ],
    history: true,
    analytics: true,
    allWallets: true,
    legalCheckbox: false,
    smartSessions: false,
    collapseWallets: false,
    walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
    connectMethodsOrder: void 0
  },
  DEFAULT_ACCOUNT_TYPES: {
    bip122: "payment",
    eip155: "smartAccount",
    polkadot: "eoa",
    solana: "eoa"
  },
  ADAPTER_TYPES: {
    UNIVERSAL: "universal",
    SOLANA: "solana",
    WAGMI: "wagmi",
    ETHERS: "ethers",
    ETHERS5: "ethers5",
    BITCOIN: "bitcoin"
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = {
  isMobile() {
    if (this.isClient()) {
      return Boolean(window?.matchMedia("(pointer:coarse)")?.matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  checkCaipNetwork(network, networkName = "") {
    return network?.caipNetworkId.toLocaleLowerCase().includes(networkName.toLowerCase());
  },
  isAndroid() {
    if (!this.isMobile()) {
      return false;
    }
    const ua = window?.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua.includes("android");
  },
  isIos() {
    if (!this.isMobile()) {
      return false;
    }
    const ua = window?.navigator.userAgent.toLowerCase();
    return ua.includes("iphone") || ua.includes("ipad");
  },
  isSafari() {
    if (!this.isClient()) {
      return false;
    }
    const ua = window?.navigator.userAgent.toLowerCase();
    return ua.includes("safari");
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil2.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry, differenceMs = ConstantsUtil2.ONE_SEC_MS) {
    return Date.now() - lastRetry >= differenceMs;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  isIframe() {
    try {
      return window?.self !== window?.top;
    } catch (e) {
      return false;
    }
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil2.FOUR_MINUTES_MS;
  },
  getNetworkId(caipAddress) {
    return caipAddress?.split(":")[1];
  },
  getPlainAddress(caipAddress) {
    return caipAddress?.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    if (this.isTelegram() && this.isAndroid()) {
      wcUri = encodeURIComponent(wcUri);
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  getOpenTargetForPlatform(target) {
    if (target === "popupWindow") {
      return target;
    }
    if (this.isTelegram()) {
      if (StorageUtil.getTelegramSocialProvider()) {
        return "_top";
      }
      return "_blank";
    }
    return target;
  },
  openHref(href, target, features) {
    window?.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
  },
  returnOpenHref(href, target, features) {
    return window?.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
  },
  isTelegram() {
    return typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Boolean(window.TelegramWebviewProxy) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Boolean(window.Telegram) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Boolean(window.TelegramWebviewProxyProto));
  },
  async preloadImage(src) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    let formattedBalance = "0.000";
    if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        const formattedValue = Math.floor(number * 1e3) / 1e3;
        if (formattedValue) {
          formattedBalance = formattedValue.toString();
        }
      }
    }
    return `${formattedBalance}${symbol ? ` ${symbol}` : ""}`;
  },
  formatBalance2(balance, symbol) {
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0";
    } else if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        formattedBalance = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
      }
    }
    return {
      value: formattedBalance ?? "0",
      rest: formattedBalance === "0" ? "000" : "",
      symbol
    };
  },
  getApiUrl() {
    return ConstantsUtil.W3M_API_URL;
  },
  getBlockchainApiUrl() {
    return ConstantsUtil.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return ConstantsUtil.PULSE_API_URL;
  },
  getUUID() {
    if (crypto?.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseError(error) {
    if (typeof error === "string") {
      return error;
    } else if (typeof error?.issues?.[0]?.message === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  },
  sortRequestedNetworks(approvedIds, requestedNetworks = []) {
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id, index) => {
        approvedIndexMap[id] = index;
      });
      requestedNetworks.sort((a2, b2) => {
        const indexA = approvedIndexMap[a2.id];
        const indexB = approvedIndexMap[b2.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks;
  },
  calculateBalance(array) {
    let sum = 0;
    for (const item of array) {
      sum += item.value ?? 0;
    }
    return sum;
  },
  formatTokenBalance(number) {
    const roundedNumber = number.toFixed(2);
    const [dollars, pennies] = roundedNumber.split(".");
    return { dollars, pennies };
  },
  isAddress(address, chain = "eip155") {
    switch (chain) {
      case "eip155":
        if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
          return false;
        } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
          return true;
        }
        return false;
      case "solana":
        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);
      default:
        return false;
    }
  },
  uniqueBy(arr, key) {
    const set = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const keyValue = item[key];
      if (set.has(keyValue)) {
        return false;
      }
      set.add(keyValue);
      return true;
    });
  },
  generateSdkVersion(adapters, platform, version2) {
    const hasNoAdapters = adapters.length === 0;
    const adapterNames = hasNoAdapters ? ConstantsUtil2.ADAPTER_TYPES.UNIVERSAL : adapters.map((adapter) => adapter.adapterType).join(",");
    return `${platform}-${adapterNames}-${version2}`;
  },
  // eslint-disable-next-line max-params
  createAccount(namespace, address, type, publicKey, path) {
    return {
      namespace,
      address,
      type,
      publicKey,
      path
    };
  },
  isCaipAddress(address) {
    if (typeof address !== "string") {
      return false;
    }
    const sections = address.split(":");
    const namespace = sections[0];
    return sections.filter(Boolean).length === 3 && namespace in ConstantsUtil.CHAIN_NAME_MAP;
  },
  isMac() {
    const ua = window?.navigator.userAgent.toLowerCase();
    return ua.includes("macintosh") && !ua.includes("safari");
  },
  formatTelegramSocialLoginUrl(url) {
    const valueToInject = `--${encodeURIComponent(window?.location.href)}`;
    const paramToInject = "state=";
    const parsedUrl = new URL(url);
    if (parsedUrl.host === "auth.magic.link") {
      const providerParam = "provider_authorization_url=";
      const providerUrl = url.substring(url.indexOf(providerParam) + providerParam.length);
      const resultUrl = this.injectIntoUrl(decodeURIComponent(providerUrl), paramToInject, valueToInject);
      return url.replace(providerUrl, encodeURIComponent(resultUrl));
    }
    return this.injectIntoUrl(url, paramToInject, valueToInject);
  },
  injectIntoUrl(url, key, appendString) {
    const keyIndex = url.indexOf(key);
    if (keyIndex === -1) {
      throw new Error(`${key} parameter not found in the URL: ${url}`);
    }
    const keyEndIndex = url.indexOf("&", keyIndex);
    const keyLength = key.length;
    const keyParamEnd = keyEndIndex !== -1 ? keyEndIndex : url.length;
    const beforeKeyValue = url.substring(0, keyIndex + keyLength);
    const currentKeyValue = url.substring(keyIndex + keyLength, keyParamEnd);
    const afterKeyValue = url.substring(keyEndIndex);
    const newKeyValue = currentKeyValue + appendString;
    const newUrl = beforeKeyValue + newKeyValue + afterKeyValue;
    return newUrl;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/OptionsUtil.js
var OptionsUtil = {
  getFeatureValue(key, features) {
    const optionValue = features?.[key];
    if (optionValue === void 0) {
      return ConstantsUtil2.DEFAULT_FEATURES[key];
    }
    return optionValue;
  },
  filterSocialsByPlatform(socials) {
    if (!socials || !socials.length) {
      return socials;
    }
    if (CoreHelperUtil.isTelegram()) {
      if (CoreHelperUtil.isIos()) {
        return socials.filter((s) => s !== "google");
      }
      if (CoreHelperUtil.isMac()) {
        return socials.filter((s) => s !== "x");
      }
      if (CoreHelperUtil.isAndroid()) {
        return socials.filter((s) => !["facebook", "x"].includes(s));
      }
    }
    return socials;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js
var state = proxy({
  features: ConstantsUtil2.DEFAULT_FEATURES,
  projectId: "",
  sdkType: "appkit",
  sdkVersion: "html-wagmi-undefined",
  defaultAccountTypes: ConstantsUtil2.DEFAULT_ACCOUNT_TYPES,
  enableNetworkSwitch: true
});
var OptionsController = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  setOptions(options) {
    Object.assign(state, options);
  },
  setFeatures(features) {
    if (!features) {
      return;
    }
    if (!state.features) {
      state.features = ConstantsUtil2.DEFAULT_FEATURES;
    }
    const newFeatures = { ...state.features, ...features };
    state.features = newFeatures;
    if (state.features.socials) {
      state.features.socials = OptionsUtil.filterSocialsByPlatform(state.features.socials);
    }
  },
  setProjectId(projectId) {
    state.projectId = projectId;
  },
  setCustomRpcUrls(customRpcUrls) {
    state.customRpcUrls = customRpcUrls;
  },
  setAllWallets(allWallets) {
    state.allWallets = allWallets;
  },
  setIncludeWalletIds(includeWalletIds) {
    state.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state.customWallets = customWallets;
  },
  setIsSiweEnabled(isSiweEnabled) {
    state.isSiweEnabled = isSiweEnabled;
  },
  setIsUniversalProvider(isUniversalProvider) {
    state.isUniversalProvider = isUniversalProvider;
  },
  setSdkVersion(sdkVersion) {
    state.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state.metadata = metadata;
  },
  setDisableAppend(disableAppend) {
    state.disableAppend = disableAppend;
  },
  setEIP6963Enabled(enableEIP6963) {
    state.enableEIP6963 = enableEIP6963;
  },
  setDebug(debug) {
    state.debug = debug;
  },
  setEnableWalletConnect(enableWalletConnect) {
    state.enableWalletConnect = enableWalletConnect;
  },
  setEnableWalletGuide(enableWalletGuide) {
    state.enableWalletGuide = enableWalletGuide;
  },
  setEnableAuthLogger(enableAuthLogger) {
    state.enableAuthLogger = enableAuthLogger;
  },
  setEnableWallets(enableWallets) {
    state.enableWallets = enableWallets;
  },
  setHasMultipleAddresses(hasMultipleAddresses) {
    state.hasMultipleAddresses = hasMultipleAddresses;
  },
  setSIWX(siwx) {
    state.siwx = siwx;
  },
  setConnectMethodsOrder(connectMethodsOrder) {
    state.features = {
      ...state.features,
      connectMethodsOrder
    };
  },
  setWalletFeaturesOrder(walletFeaturesOrder) {
    state.features = {
      ...state.features,
      walletFeaturesOrder
    };
  },
  setSocialsOrder(socialsOrder) {
    state.features = {
      ...state.features,
      socials: socialsOrder
    };
  },
  setCollapseWallets(collapseWallets) {
    state.features = {
      ...state.features,
      collapseWallets
    };
  },
  setEnableEmbedded(enableEmbedded) {
    state.enableEmbedded = enableEmbedded;
  },
  setAllowUnsupportedChain(allowUnsupportedChain) {
    state.allowUnsupportedChain = allowUnsupportedChain;
  },
  setManualWCControl(manualWCControl) {
    state.manualWCControl = manualWCControl;
  },
  setEnableNetworkSwitch(enableNetworkSwitch) {
    state.enableNetworkSwitch = enableNetworkSwitch;
  },
  setDefaultAccountTypes(defaultAccountType = {}) {
    Object.entries(defaultAccountType).forEach(([namespace, accountType]) => {
      if (accountType) {
        state.defaultAccountTypes[namespace] = accountType;
      }
    });
  },
  setUniversalProviderConfigOverride(universalProviderConfigOverride) {
    state.universalProviderConfigOverride = universalProviderConfigOverride;
  },
  getUniversalProviderConfigOverride() {
    return state.universalProviderConfigOverride;
  },
  getSnapshot() {
    return snapshot(state);
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AssetController.js
var state2 = proxy({
  walletImages: {},
  networkImages: {},
  chainImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
});
var AssetController = {
  state: state2,
  subscribeNetworkImages(callback) {
    return subscribe(state2.networkImages, () => callback(state2.networkImages));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  setWalletImage(key, value) {
    state2.walletImages[key] = value;
  },
  setNetworkImage(key, value) {
    state2.networkImages[key] = value;
  },
  setChainImage(key, value) {
    state2.chainImages[key] = value;
  },
  setConnectorImage(key, value) {
    state2.connectorImages = { ...state2.connectorImages, [key]: value };
  },
  setTokenImage(key, value) {
    state2.tokenImages[key] = value;
  },
  setCurrencyImage(key, value) {
    state2.currencyImages[key] = value;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/AssetUtil.js
var namespaceImageIds = {
  // Ethereum
  eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
  // Solana
  solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
  // Polkadot
  polkadot: "",
  // Bitcoin
  bip122: "0b4838db-0161-4ffe-022d-532bf03dba00"
};
var state3 = proxy({
  networkImagePromises: {}
});
var AssetUtil = {
  async fetchWalletImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    await ApiController._fetchWalletImage(imageId);
    return this.getWalletImageById(imageId);
  },
  async fetchNetworkImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    const existingImage = this.getNetworkImageById(imageId);
    if (existingImage) {
      return existingImage;
    }
    if (!state3.networkImagePromises[imageId]) {
      state3.networkImagePromises[imageId] = ApiController._fetchNetworkImage(imageId);
    }
    await state3.networkImagePromises[imageId];
    return this.getNetworkImageById(imageId);
  },
  getWalletImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.walletImages[imageId];
  },
  getWalletImage(wallet) {
    if (wallet?.image_url) {
      return wallet?.image_url;
    }
    if (wallet?.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network?.assets?.imageUrl) {
      return network?.assets?.imageUrl;
    }
    if (network?.assets?.imageId) {
      return AssetController.state.networkImages[network.assets.imageId];
    }
    return void 0;
  },
  getNetworkImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.networkImages[imageId];
  },
  getConnectorImage(connector) {
    if (connector?.imageUrl) {
      return connector.imageUrl;
    }
    if (connector?.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  },
  getChainImage(chain) {
    return AssetController.state.networkImages[namespaceImageIds[chain]];
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/FetchUtil.js
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err;
  }
  return response;
}
var FetchUtil = class {
  constructor({ baseUrl: baseUrl4, clientId }) {
    this.baseUrl = baseUrl4;
    this.clientId = clientId;
  }
  async get({ headers, signal, cache, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal, cache });
    return response.json();
  }
  async getBlob({ headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal });
    return response.blob();
  }
  async post({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async put({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async delete({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value) {
          url.searchParams.append(key, value);
        }
      });
    }
    if (this.clientId) {
      url.searchParams.append("clientId", this.clientId);
    }
    return url;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/MobileWallet.js
var MobileWalletUtil = {
  /**
   * Handles mobile wallet redirection for wallets that have Universal Links.
   *
   * @param {Object} properties - The properties object.
   * @param {string} properties.name - The name of the wallet.
   */
  handleSolanaDeeplinkRedirect(name) {
    if (ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA) {
      const href = window.location.href;
      const encodedHref = encodeURIComponent(href);
      if (name === "Phantom" && !("phantom" in window)) {
        const protocol = href.startsWith("https") ? "https" : "http";
        const host = href.split("/")[2];
        const encodedRef = encodeURIComponent(`${protocol}://${host}`);
        window.location.href = `https://phantom.app/ul/browse/${encodedHref}?ref=${encodedRef}`;
      }
      if (name === "Coinbase Wallet" && !("coinbaseSolana" in window)) {
        window.location.href = `https://go.cb-w.com/dapp?cb_url=${encodedHref}`;
      }
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js
var DEFAULT_STATE = Object.freeze({
  message: "",
  variant: "success",
  svg: void 0,
  open: false,
  autoClose: true
});
var state4 = proxy({
  ...DEFAULT_STATE
});
var SnackController = {
  state: state4,
  subscribeKey(key, callback) {
    return subscribeKey(state4, key, callback);
  },
  showLoading(message, options = {}) {
    this._showMessage({ message, variant: "loading", ...options });
  },
  showSuccess(message) {
    this._showMessage({ message, variant: "success" });
  },
  showSvg(message, svg) {
    this._showMessage({ message, svg });
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    this._showMessage({ message: errorMessage, variant: "error" });
  },
  hide() {
    state4.message = DEFAULT_STATE.message;
    state4.variant = DEFAULT_STATE.variant;
    state4.svg = DEFAULT_STATE.svg;
    state4.open = DEFAULT_STATE.open;
    state4.autoClose = DEFAULT_STATE.autoClose;
  },
  _showMessage({ message, svg, variant = "success", autoClose = DEFAULT_STATE.autoClose }) {
    if (state4.open) {
      state4.open = false;
      setTimeout(() => {
        state4.message = message;
        state4.variant = variant;
        state4.svg = svg;
        state4.open = true;
        state4.autoClose = autoClose;
      }, 150);
    } else {
      state4.message = message;
      state4.variant = variant;
      state4.svg = svg;
      state4.open = true;
      state4.autoClose = autoClose;
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var DEFAULT_OPTIONS = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
};
var baseUrl = CoreHelperUtil.getBlockchainApiUrl();
var state5 = proxy({
  clientId: null,
  api: new FetchUtil({ baseUrl, clientId: null }),
  supportedChains: { http: [], ws: [] }
});
var BlockchainApiController = {
  state: state5,
  async get(request) {
    const { st: st2, sv } = BlockchainApiController.getSdkProperties();
    const projectId = OptionsController.state.projectId;
    const params = {
      ...request.params || {},
      st: st2,
      sv,
      projectId
    };
    return state5.api.get({
      ...request,
      params
    });
  },
  getSdkProperties() {
    const { sdkType, sdkVersion } = OptionsController.state;
    return {
      st: sdkType || "unknown",
      sv: sdkVersion || "unknown"
    };
  },
  async isNetworkSupported(networkId) {
    if (!networkId) {
      return false;
    }
    try {
      if (!state5.supportedChains.http.length) {
        await BlockchainApiController.getSupportedNetworks();
      }
    } catch (e) {
      return false;
    }
    return state5.supportedChains.http.includes(networkId);
  },
  async getSupportedNetworks() {
    const supportedChains = await BlockchainApiController.get({
      path: "v1/supported-chains"
    });
    state5.supportedChains = supportedChains;
    return supportedChains;
  },
  async fetchIdentity({ address, caipNetworkId }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(caipNetworkId);
    if (!isSupported) {
      return { avatar: "", name: "" };
    }
    const identityCache = StorageUtil.getIdentityFromCacheForAddress(address);
    if (identityCache) {
      return identityCache;
    }
    const result = await BlockchainApiController.get({
      path: `/v1/identity/${address}`,
      params: {
        sender: ChainController.state.activeCaipAddress ? CoreHelperUtil.getPlainAddress(ChainController.state.activeCaipAddress) : void 0
      }
    });
    StorageUtil.updateIdentityCache({
      address,
      identity: result,
      timestamp: Date.now()
    });
    return result;
  },
  async fetchTransactions({ account, cursor, onramp, signal, cache, chainId }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { data: [], next: void 0 };
    }
    return BlockchainApiController.get({
      path: `/v1/account/${account}/history`,
      params: {
        cursor,
        onramp,
        chainId
      },
      signal,
      cache
    });
  },
  async fetchSwapQuote({ amount, userAddress, from: from6, to, gasPrice }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { quotes: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/quotes`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        amount,
        userAddress,
        from: from6,
        to,
        gasPrice
      }
    });
  },
  async fetchSwapTokens({ chainId }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { tokens: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/tokens`,
      params: { chainId }
    });
  },
  async fetchTokenPrice({ addresses }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { fungibles: [] };
    }
    return state5.api.post({
      path: "/v1/fungible/price",
      body: {
        currency: "usd",
        addresses,
        projectId: OptionsController.state.projectId
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async fetchSwapAllowance({ tokenAddress, userAddress }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { allowance: "0" };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/allowance`,
      params: {
        tokenAddress,
        userAddress
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async fetchGasPrice({ chainId }) {
    const { st: st2, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Gas Price");
    }
    return BlockchainApiController.get({
      path: `/v1/convert/gas-price`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        chainId,
        st: st2,
        sv
      }
    });
  },
  async generateSwapCalldata({ amount, from: from6, to, userAddress, disableEstimate }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Swaps");
    }
    return state5.api.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount,
        eip155: {
          slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE
        },
        projectId: OptionsController.state.projectId,
        from: from6,
        to,
        userAddress,
        disableEstimate
      }
    });
  },
  async generateApproveCalldata({ from: from6, to, userAddress }) {
    const { st: st2, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Swaps");
    }
    return BlockchainApiController.get({
      path: `/v1/convert/build-approve`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        userAddress,
        from: from6,
        to,
        st: st2,
        sv
      }
    });
  },
  async getBalance(address, chainId, forceUpdate) {
    const { st: st2, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      SnackController.showError("Token Balance Unavailable");
      return { balances: [] };
    }
    const caipAddress = `${chainId}:${address}`;
    const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);
    if (cachedBalance) {
      return cachedBalance;
    }
    const balance = await BlockchainApiController.get({
      path: `/v1/account/${address}/balance`,
      params: {
        currency: "usd",
        chainId,
        forceUpdate,
        st: st2,
        sv
      }
    });
    StorageUtil.updateBalanceCache({
      caipAddress,
      balance,
      timestamp: Date.now()
    });
    return balance;
  },
  async lookupEnsName(name) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { addresses: {}, attributes: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/profile/account/${name}`,
      params: { apiVersion: "2" }
    });
  },
  async reverseLookupEnsName({ address }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return [];
    }
    return BlockchainApiController.get({
      path: `/v1/profile/reverse/${address}`,
      params: {
        sender: AccountController.state.address,
        apiVersion: "2"
      }
    });
  },
  async getEnsNameSuggestions(name) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { suggestions: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/profile/suggestions/${name}`,
      params: { zone: "reown.id" }
    });
  },
  async registerEnsName({ coinType, address, message, signature }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { success: false };
    }
    return state5.api.post({
      path: `/v1/profile/account`,
      body: { coin_type: coinType, address, message, signature },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return "";
    }
    const response = await state5.api.post({
      path: `/v1/generators/onrampurl`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        destinationWallets,
        defaultNetwork,
        partnerUserId,
        defaultExperience: "buy",
        presetCryptoAmount: purchaseAmount,
        presetFiatAmount: paymentAmount
      }
    });
    return response.url;
  },
  async getOnrampOptions() {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { paymentCurrencies: [], purchaseCurrencies: [] };
    }
    try {
      const response = await BlockchainApiController.get({
        path: `/v1/onramp/options`
      });
      return response;
    } catch (e) {
      return DEFAULT_OPTIONS;
    }
  },
  async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
    try {
      const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
      if (!isSupported) {
        return null;
      }
      const response = await state5.api.post({
        path: `/v1/onramp/quote`,
        params: {
          projectId: OptionsController.state.projectId
        },
        body: {
          purchaseCurrency,
          paymentCurrency,
          amount,
          network
        }
      });
      return response;
    } catch (e) {
      return {
        coinbaseFee: { amount, currency: paymentCurrency.id },
        networkFee: { amount, currency: paymentCurrency.id },
        paymentSubtotal: { amount, currency: paymentCurrency.id },
        paymentTotal: { amount, currency: paymentCurrency.id },
        purchaseAmount: { amount, currency: paymentCurrency.id },
        quoteId: "mocked-quote-id"
      };
    }
  },
  async getSmartSessions(caipAddress) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return [];
    }
    return BlockchainApiController.get({
      path: `/v1/sessions/${caipAddress}`
    });
  },
  async revokeSmartSession(address, pci, signature) {
    const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
    if (!isSupported) {
      return { success: false };
    }
    return state5.api.post({
      path: `/v1/sessions/${address}/revoke`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        pci,
        signature
      }
    });
  },
  setClientId(clientId) {
    state5.clientId = clientId;
    state5.api = new FetchUtil({ baseUrl, clientId });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var state6 = proxy({
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
});
var AccountController = {
  state: state6,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state6, ref(newState));
  },
  subscribe(callback) {
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        return callback(accountState2);
      }
      return void 0;
    });
  },
  subscribeKey(property, callback, chain) {
    let prev = void 0;
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        const nextValue = accountState2[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    }, chain);
  },
  setStatus(status, chain) {
    ChainController.setAccountProp("status", status, chain);
  },
  getCaipAddress(chain) {
    return ChainController.getAccountProp("caipAddress", chain);
  },
  setCaipAddress(caipAddress, chain) {
    const newAddress = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (chain === ChainController.state.activeChain) {
      ChainController.state.activeCaipAddress = caipAddress;
    }
    ChainController.setAccountProp("caipAddress", caipAddress, chain);
    ChainController.setAccountProp("address", newAddress, chain);
  },
  setBalance(balance, balanceSymbol, chain) {
    ChainController.setAccountProp("balance", balance, chain);
    ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain);
  },
  setProfileName(profileName, chain) {
    ChainController.setAccountProp("profileName", profileName, chain);
  },
  setProfileImage(profileImage, chain) {
    ChainController.setAccountProp("profileImage", profileImage, chain);
  },
  setUser(user, chain) {
    ChainController.setAccountProp("user", user, chain);
  },
  setAddressExplorerUrl(explorerUrl, chain) {
    ChainController.setAccountProp("addressExplorerUrl", explorerUrl, chain);
  },
  setSmartAccountDeployed(isDeployed, chain) {
    ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain);
  },
  setCurrentTab(currentTab) {
    ChainController.setAccountProp("currentTab", currentTab, ChainController.state.activeChain);
  },
  setTokenBalance(tokenBalance, chain) {
    if (tokenBalance) {
      ChainController.setAccountProp("tokenBalance", tokenBalance, chain);
    }
  },
  setShouldUpdateToAddress(address, chain) {
    ChainController.setAccountProp("shouldUpdateToAddress", address, chain);
  },
  setAllAccounts(accounts, namespace) {
    ChainController.setAccountProp("allAccounts", accounts, namespace);
  },
  addAddressLabel(address, label, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.set(address, label);
    ChainController.setAccountProp("addressLabels", map, chain);
  },
  removeAddressLabel(address, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.delete(address);
    ChainController.setAccountProp("addressLabels", map, chain);
  },
  setConnectedWalletInfo(connectedWalletInfo, chain) {
    ChainController.setAccountProp("connectedWalletInfo", connectedWalletInfo, chain, false);
  },
  setPreferredAccountType(preferredAccountType, chain) {
    ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
  },
  setSocialProvider(socialProvider, chain) {
    if (socialProvider) {
      ChainController.setAccountProp("socialProvider", socialProvider, chain);
    }
  },
  setSocialWindow(socialWindow, chain) {
    ChainController.setAccountProp("socialWindow", socialWindow ? ref(socialWindow) : void 0, chain);
  },
  setFarcasterUrl(farcasterUrl, chain) {
    ChainController.setAccountProp("farcasterUrl", farcasterUrl, chain);
  },
  async fetchTokenBalance(onError) {
    state6.balanceLoading = true;
    const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;
    const chain = ChainController.state.activeCaipNetwork?.chainNamespace;
    const caipAddress = ChainController.state.activeCaipAddress;
    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (state6.lastRetry && !CoreHelperUtil.isAllowedRetry(state6.lastRetry, 30 * ConstantsUtil2.ONE_SEC_MS)) {
      state6.balanceLoading = false;
      return [];
    }
    try {
      if (address && chainId && chain) {
        const response = await BlockchainApiController.getBalance(address, chainId);
        const filteredBalances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
        this.setTokenBalance(filteredBalances, chain);
        state6.lastRetry = void 0;
        state6.balanceLoading = false;
        return filteredBalances;
      }
    } catch (error) {
      state6.lastRetry = Date.now();
      onError?.(error);
      SnackController.showError("Token Balance Unavailable");
    } finally {
      state6.balanceLoading = false;
    }
    return [];
  },
  resetAccount(chain) {
    ChainController.resetAccount(chain);
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/solana-adapter/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e, s, r2) => s in e ? a(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var c = (e, s, r2) => u(e, typeof s != "symbol" ? s + "" : s, r2);
var h = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, c(this, "protocol", "wc"), c(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e, s, r2) => s in e ? p(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var v = (e, s, r2) => b(e, typeof s != "symbol" ? s + "" : s, r2);
var I = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y = class {
  constructor(s, r2) {
    this.logger = s, this.core = r2;
  }
};
var m = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var d = class extends IEvents {
  constructor(s) {
    super();
  }
};
var f = class {
  constructor(s, r2, t, q2) {
    this.core = s, this.logger = r2, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s, r2) {
    super(), this.relayer = s, this.logger = r2;
  }
};
var S = class extends IEvents {
  constructor(s, r2) {
    super(), this.core = s, this.logger = r2;
  }
};
var M = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.store = t;
  }
};
var O = class {
  constructor(s, r2) {
    this.projectId = s, this.logger = r2;
  }
};
var R = class {
  constructor(s, r2, t) {
    this.core = s, this.logger = r2, this.telemetryEnabled = t;
  }
};
var T = Object.defineProperty;
var k = (e, s, r2) => s in e ? T(e, s, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s] = r2;
var i = (e, s, r2) => k(e, typeof s != "symbol" ? s + "" : s, r2);
var J = class {
  constructor(s) {
    this.opts = s, i(this, "protocol", "wc"), i(this, "version", 2);
  }
};
var V = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@walletconnect/solana-adapter/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_2, i3) => i3));
var Pi = Id.map((i3) => (9 * i3 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i3 = 0; i3 < 4; i3++)
  for (let j of [idxL, idxR])
    j.push(j[i3].map((k3) => Rho[k3]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL = idxL.map((idx, i3) => idx.map((j) => shifts[i3][j]));
var shiftsR = idxR.map((idx, i3) => idx.map((j) => shifts[i3][j]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f2(group, x3, y3, z2) {
  if (group === 0)
    return x3 ^ y3 ^ z2;
  else if (group === 1)
    return x3 & y3 | ~x3 & z2;
  else if (group === 2)
    return (x3 | ~y3) ^ z2;
  else if (group === 3)
    return x3 & z2 | y3 & ~z2;
  else
    return x3 ^ (y3 | ~z2);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3, h4 } = this;
    return [h0, h1, h22, h3, h4];
  }
  set(h0, h1, h22, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      R_BUF[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br2 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr2 = dl, el = this.h4 | 0, er3 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr3 = idxR[group];
      const sl = shiftsL[group], sr2 = shiftsR[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl(al + f2(group, bl, cl, dl) + R_BUF[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr3 = rotl(ar2 + f2(rGroup, br2, cr2, dr2) + R_BUF[rr3[i3]] + hbr, sr2[i3]) + er3 | 0;
        ar2 = er3, er3 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr3;
      }
    }
    this.set(this.h1 + cl + dr2 | 0, this.h2 + dl + er3 | 0, this.h3 + el + ar2 | 0, this.h4 + al + br2 | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/version.js
var version = "0.1.1";

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version;
}

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Errors.js
var BaseError2 = class _BaseError extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      if (options.cause instanceof _BaseError) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if (options.cause?.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath = (() => {
      if (options.cause instanceof _BaseError)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath ? `See: ${docs}` : void 0
      ] : []
    ].filter((x3) => typeof x3 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath;
    this.shortMessage = shortMessage;
  }
  walk(fn3) {
    return walk(this, fn3);
  }
};
function walk(err, fn3) {
  if (fn3?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn3);
  return fn3 ? null : err;
}

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/internal/bytes.js
function assertSize(bytes, size_) {
  if (size2(bytes) > size_)
    throw new SizeOverflowError({
      givenSize: size2(bytes),
      maxSize: size_
    });
}
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function pad2(bytes, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return bytes;
  if (bytes.length > size4)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size4,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size4);
  for (let i3 = 0; i3 < size4; i3++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i3 : size4 - i3 - 1] = bytes[padEnd ? i3 : bytes.length - i3 - 1];
  }
  return paddedBytes;
}

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/internal/hex.js
function assertSize2(hex, size_) {
  if (size3(hex) > size_)
    throw new SizeOverflowError2({
      givenSize: size3(hex),
      maxSize: size_
    });
}
function pad3(hex_, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Bytes.js
var decoder = new TextDecoder();
var encoder = new TextEncoder();
function from(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex2(value);
  return fromArray(value);
}
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex2(value, options = {}) {
  const { size: size4 } = options;
  let hex = value;
  if (size4) {
    assertSize2(value, size4);
    hex = padRight(value, size4);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString(value, options = {}) {
  const { size: size4 } = options;
  const bytes = encoder.encode(value);
  if (typeof size4 === "number") {
    assertSize(bytes, size4);
    return padRight2(bytes, size4);
  }
  return bytes;
}
function padRight2(value, size4) {
  return pad2(value, { dir: "right", size: size4 });
}
function size2(value) {
  return value.length;
}
var SizeOverflowError = class extends BaseError2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError = class extends BaseError2 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Hex.js
var encoder2 = new TextEncoder();
var hexes = Array.from({ length: 256 }, (_v, i3) => i3.toString(16).padStart(2, "0"));
function concat2(...values) {
  return `0x${values.reduce((acc, x3) => acc + x3.replace("0x", ""), "")}`;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes2(value, options = {}) {
  let string = "";
  for (let i3 = 0; i3 < value.length; i3++)
    string += hexes[value[i3]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed, size: size4 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size4)
    return padLeft(hex, size4);
  return hex;
}
function fromString2(value, options = {}) {
  return fromBytes2(encoder2.encode(value), options);
}
function padLeft(value, size4) {
  return pad3(value, { dir: "left", size: size4 });
}
function padRight(value, size4) {
  return pad3(value, { dir: "right", size: size4 });
}
function size3(value) {
  return Math.ceil((value.length - 2) / 2);
}
var IntegerOutOfRangeError = class extends BaseError2 {
  constructor({ max, min, signed, size: size4, value }) {
    super(`Number \`${value}\` is not in safe${size4 ? ` ${size4 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var SizeOverflowError2 = class extends BaseError2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError2 = class extends BaseError2 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as: as2 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as2 === "Bytes")
    return bytes;
  return fromBytes2(bytes);
}

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hash[i3 >> 1] >> 4 >= 8 && characters[i3]) {
      characters[i3] = characters[i3].toUpperCase();
    }
    if ((hash[i3 >> 1] & 15) >= 8 && characters[i3 + 1]) {
      characters[i3 + 1] = characters[i3 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError2 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError2 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i3 = 0; i3 < types.length; i3++) {
    const type = types[i3];
    const value = values[i3];
    data.push(encodePacked2.encode(type, value));
  }
  return concat2(...data);
}
(function(encodePacked3) {
  function encode4(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        data.push(encode4(childType, value[i3], true));
      }
      if (data.length === 0)
        return "0x";
      return concat2(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode4;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError2 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i3 = 0; i3 < ALPHABET2.length; i3++) {
    const x3 = ALPHABET2.charAt(i3);
    const xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i3;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode4(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size4);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i3 = 0;
      for (let it1 = size4 - 1; (carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    let it22 = size4 - length;
    while (it22 !== size4 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size4; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size4 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size4);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i3 = 0;
      for (let it3 = size4 - 1; (carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    let it4 = size4 - length;
    while (it4 !== size4 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size4 - it4));
    let j = zeroes;
    while (it4 !== size4) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode2
  };
}
var esm_default = base;

// node_modules/@walletconnect/solana-adapter/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/dist/index.es.js
var import_elliptic = __toESM(require_elliptic());
function Ne(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Io(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function je(e, ...t) {
  if (!Io(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function ot(e) {
  if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne(e.outputLen), Ne(e.blockLen);
}
function me(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function sn2(e, t) {
  je(e);
  const n2 = t.outputLen;
  if (e.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
var Ce = BigInt(2 ** 32 - 1);
var cn = BigInt(32);
function Oo(e, t = false) {
  return t ? { h: Number(e & Ce), l: Number(e >> cn & Ce) } : { h: Number(e >> cn & Ce) | 0, l: Number(e & Ce) | 0 };
}
function Ao(e, t = false) {
  let n2 = new Uint32Array(e.length), r2 = new Uint32Array(e.length);
  for (let o2 = 0; o2 < e.length; o2++) {
    const { h: s, l: i3 } = Oo(e[o2], t);
    [n2[o2], r2[o2]] = [s, i3];
  }
  return [n2, r2];
}
var No = (e, t, n2) => e << n2 | t >>> 32 - n2;
var So = (e, t, n2) => t << n2 | e >>> 32 - n2;
var Uo = (e, t, n2) => t << n2 - 32 | e >>> 64 - n2;
var _o = (e, t, n2) => e << n2 - 32 | t >>> 64 - n2;
var be = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function To(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function st(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function J2(e, t) {
  return e << 32 - t | e >>> t;
}
var an = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function $o(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function un(e) {
  for (let t = 0; t < e.length; t++) e[t] = $o(e[t]);
}
function Ro(e) {
  if (typeof e != "string") throw new Error("utf8ToBytes expected string, got " + typeof e);
  return new Uint8Array(new TextEncoder().encode(e));
}
function we(e) {
  return typeof e == "string" && (e = Ro(e)), je(e), e;
}
var it = class {
  clone() {
    return this._cloneInto();
  }
};
function fn(e) {
  const t = (r2) => e().update(we(r2)).digest(), n2 = e();
  return t.outputLen = n2.outputLen, t.blockLen = n2.blockLen, t.create = () => e(), t;
}
function Se(e = 32) {
  if (be && typeof be.getRandomValues == "function") return be.getRandomValues(new Uint8Array(e));
  if (be && typeof be.randomBytes == "function") return be.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
var ln = [];
var dn = [];
var hn = [];
var Po = BigInt(0);
var Ue = BigInt(1);
var Bo = BigInt(2);
var Lo = BigInt(7);
var jo = BigInt(256);
var Co = BigInt(113);
for (let e = 0, t = Ue, n2 = 1, r2 = 0; e < 24; e++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], ln.push(2 * (5 * r2 + n2)), dn.push((e + 1) * (e + 2) / 2 % 64);
  let o2 = Po;
  for (let s = 0; s < 7; s++) t = (t << Ue ^ (t >> Lo) * Co) % jo, t & Bo && (o2 ^= Ue << (Ue << BigInt(s)) - Ue);
  hn.push(o2);
}
var [ko, Do] = Ao(hn, true);
var pn = (e, t, n2) => n2 > 32 ? Uo(e, t, n2) : No(e, t, n2);
var gn = (e, t, n2) => n2 > 32 ? _o(e, t, n2) : So(e, t, n2);
function Mo(e, t = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - t; r2 < 24; r2++) {
    for (let i3 = 0; i3 < 10; i3++) n2[i3] = e[i3] ^ e[i3 + 10] ^ e[i3 + 20] ^ e[i3 + 30] ^ e[i3 + 40];
    for (let i3 = 0; i3 < 10; i3 += 2) {
      const c2 = (i3 + 8) % 10, u2 = (i3 + 2) % 10, a2 = n2[u2], l2 = n2[u2 + 1], f5 = pn(a2, l2, 1) ^ n2[c2], d2 = gn(a2, l2, 1) ^ n2[c2 + 1];
      for (let g = 0; g < 50; g += 10) e[i3 + g] ^= f5, e[i3 + g + 1] ^= d2;
    }
    let o2 = e[2], s = e[3];
    for (let i3 = 0; i3 < 24; i3++) {
      const c2 = dn[i3], u2 = pn(o2, s, c2), a2 = gn(o2, s, c2), l2 = ln[i3];
      o2 = e[l2], s = e[l2 + 1], e[l2] = u2, e[l2 + 1] = a2;
    }
    for (let i3 = 0; i3 < 50; i3 += 10) {
      for (let c2 = 0; c2 < 10; c2++) n2[c2] = e[i3 + c2];
      for (let c2 = 0; c2 < 10; c2++) e[i3 + c2] ^= ~n2[(c2 + 2) % 10] & n2[(c2 + 4) % 10];
    }
    e[0] ^= ko[r2], e[1] ^= Do[r2];
  }
  n2.fill(0);
}
var Lt = class _Lt extends it {
  constructor(t, n2, r2, o2 = false, s = 24) {
    if (super(), this.blockLen = t, this.suffix = n2, this.outputLen = r2, this.enableXOF = o2, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne(r2), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = To(this.state);
  }
  keccak() {
    an || un(this.state32), Mo(this.state32, this.rounds), an || un(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    me(this);
    const { blockLen: n2, state: r2 } = this;
    t = we(t);
    const o2 = t.length;
    for (let s = 0; s < o2; ) {
      const i3 = Math.min(n2 - this.pos, o2 - s);
      for (let c2 = 0; c2 < i3; c2++) r2[this.pos++] ^= t[s++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t, suffix: n2, pos: r2, blockLen: o2 } = this;
    t[r2] ^= n2, (n2 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), t[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    me(this, false), je(t), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, s = t.length; o2 < s; ) {
      this.posOut >= r2 && this.keccak();
      const i3 = Math.min(r2 - this.posOut, s - o2);
      t.set(n2.subarray(this.posOut, this.posOut + i3), o2), this.posOut += i3, o2 += i3;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Ne(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (sn2(t, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n2, suffix: r2, outputLen: o2, rounds: s, enableXOF: i3 } = this;
    return t || (t = new _Lt(n2, r2, o2, i3, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r2, t.outputLen = o2, t.enableXOF = i3, t.destroyed = this.destroyed, t;
  }
};
var Vo = (e, t, n2) => fn(() => new Lt(t, e, n2));
var Ho = Vo(1, 136, 256 / 8);
function ht(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e);
}
function Bn(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function F(e, ...t) {
  if (!Bn(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function Ln(e, t = true) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function cs(e, t) {
  F(e);
  const n2 = t.outputLen;
  if (e.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function jn(e) {
  if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`);
}
var se = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
var as = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var us = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!us) throw new Error("Non little-endian hardware is not supported");
function fs(e) {
  if (typeof e != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function pt(e) {
  if (typeof e == "string") e = fs(e);
  else if (Bn(e)) e = gt(e);
  else throw new Error("Uint8Array expected, got " + typeof e);
  return e;
}
function ls(e, t) {
  if (t == null || typeof t != "object") throw new Error("options must be defined");
  return Object.assign(e, t);
}
function ds(e, t) {
  if (e.length !== t.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < e.length; r2++) n2 |= e[r2] ^ t[r2];
  return n2 === 0;
}
var hs = (e, t) => {
  function n2(r2, ...o2) {
    if (F(r2), e.nonceLength !== void 0) {
      const l2 = o2[0];
      if (!l2) throw new Error("nonce / iv required");
      e.varSizeNonce ? F(l2) : F(l2, e.nonceLength);
    }
    const s = e.tagLength;
    s && o2[1] !== void 0 && F(o2[1]);
    const i3 = t(r2, ...o2), c2 = (l2, f5) => {
      if (f5 !== void 0) {
        if (l2 !== 2) throw new Error("cipher output not supported");
        F(f5);
      }
    };
    let u2 = false;
    return { encrypt(l2, f5) {
      if (u2) throw new Error("cannot encrypt() twice with same key + nonce");
      return u2 = true, F(l2), c2(i3.encrypt.length, f5), i3.encrypt(l2, f5);
    }, decrypt(l2, f5) {
      if (F(l2), s && l2.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
      return c2(i3.decrypt.length, f5), i3.decrypt(l2, f5);
    } };
  }
  return Object.assign(n2, e), n2;
};
function Cn(e, t, n2 = true) {
  if (t === void 0) return new Uint8Array(e);
  if (t.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + t.length);
  if (n2 && !ps(t)) throw new Error("invalid output, must be aligned");
  return t;
}
function kn(e, t, n2, r2) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i3 = Number(n2 >> o2 & s), c2 = Number(n2 & s), u2 = r2 ? 4 : 0, a2 = r2 ? 0 : 4;
  e.setUint32(t + u2, i3, r2), e.setUint32(t + a2, c2, r2);
}
function ps(e) {
  return e.byteOffset % 4 === 0;
}
function gt(e) {
  return Uint8Array.from(e);
}
function Ee(...e) {
  for (let t = 0; t < e.length; t++) e[t].fill(0);
}
var Dn = (e) => Uint8Array.from(e.split("").map((t) => t.charCodeAt(0)));
var gs = Dn("expand 16-byte k");
var ys = Dn("expand 32-byte k");
var ms = se(gs);
var bs = se(ys);
function x(e, t) {
  return e << t | e >>> 32 - t;
}
function yt(e) {
  return e.byteOffset % 4 === 0;
}
var Ve = 64;
var ws = 16;
var Mn = 2 ** 32 - 1;
var Vn = new Uint32Array();
function Es(e, t, n2, r2, o2, s, i3, c2) {
  const u2 = o2.length, a2 = new Uint8Array(Ve), l2 = se(a2), f5 = yt(o2) && yt(s), d2 = f5 ? se(o2) : Vn, g = f5 ? se(s) : Vn;
  for (let y3 = 0; y3 < u2; i3++) {
    if (e(t, n2, r2, l2, i3, c2), i3 >= Mn) throw new Error("arx: counter overflow");
    const h3 = Math.min(Ve, u2 - y3);
    if (f5 && h3 === Ve) {
      const m2 = y3 / 4;
      if (y3 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let L = 0, b2; L < ws; L++) b2 = m2 + L, g[b2] = d2[b2] ^ l2[L];
      y3 += Ve;
      continue;
    }
    for (let m2 = 0, L; m2 < h3; m2++) L = y3 + m2, s[L] = o2[L] ^ a2[m2];
    y3 += h3;
  }
}
function vs(e, t) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o2, counterRight: s, rounds: i3 } = ls({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t);
  if (typeof e != "function") throw new Error("core must be a function");
  return ht(o2), ht(i3), jn(s), jn(n2), (c2, u2, a2, l2, f5 = 0) => {
    F(c2), F(u2), F(a2);
    const d2 = a2.length;
    if (l2 === void 0 && (l2 = new Uint8Array(d2)), F(l2), ht(f5), f5 < 0 || f5 >= Mn) throw new Error("arx: counter overflow");
    if (l2.length < d2) throw new Error(`arx: output (${l2.length}) is shorter than data (${d2})`);
    const g = [];
    let y3 = c2.length, h3, m2;
    if (y3 === 32) g.push(h3 = gt(c2)), m2 = bs;
    else if (y3 === 16 && n2) h3 = new Uint8Array(32), h3.set(c2), h3.set(c2, 16), m2 = ms, g.push(h3);
    else throw new Error(`arx: invalid 32-byte key, got length=${y3}`);
    yt(u2) || g.push(u2 = gt(u2));
    const L = se(h3);
    if (r2) {
      if (u2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(m2, L, se(u2.subarray(0, 16)), L), u2 = u2.subarray(16);
    }
    const b2 = 16 - o2;
    if (b2 !== u2.length) throw new Error(`arx: nonce must be ${b2} or 16 bytes`);
    if (b2 !== 12) {
      const O3 = new Uint8Array(12);
      O3.set(u2, s ? 0 : 12 - u2.length), u2 = O3, g.push(u2);
    }
    const _2 = se(u2);
    return Es(e, m2, L, _2, a2, l2, f5, i3), Ee(...g), l2;
  };
}
var M2 = (e, t) => e[t++] & 255 | (e[t++] & 255) << 8;
var xs = class {
  constructor(t) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t = pt(t), F(t, 32);
    const n2 = M2(t, 0), r2 = M2(t, 2), o2 = M2(t, 4), s = M2(t, 6), i3 = M2(t, 8), c2 = M2(t, 10), u2 = M2(t, 12), a2 = M2(t, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i3 << 12) & 255, this.r[5] = i3 >>> 1 & 8190, this.r[6] = (i3 >>> 14 | c2 << 2) & 8191, this.r[7] = (c2 >>> 11 | u2 << 5) & 8065, this.r[8] = (u2 >>> 8 | a2 << 8) & 8191, this.r[9] = a2 >>> 5 & 127;
    for (let l2 = 0; l2 < 8; l2++) this.pad[l2] = M2(t, 16 + 2 * l2);
  }
  process(t, n2, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: s, r: i3 } = this, c2 = i3[0], u2 = i3[1], a2 = i3[2], l2 = i3[3], f5 = i3[4], d2 = i3[5], g = i3[6], y3 = i3[7], h3 = i3[8], m2 = i3[9], L = M2(t, n2 + 0), b2 = M2(t, n2 + 2), _2 = M2(t, n2 + 4), O3 = M2(t, n2 + 6), k3 = M2(t, n2 + 8), E2 = M2(t, n2 + 10), B2 = M2(t, n2 + 12), j = M2(t, n2 + 14);
    let v2 = s[0] + (L & 8191), I2 = s[1] + ((L >>> 13 | b2 << 3) & 8191), w = s[2] + ((b2 >>> 10 | _2 << 6) & 8191), R2 = s[3] + ((_2 >>> 7 | O3 << 9) & 8191), A2 = s[4] + ((O3 >>> 4 | k3 << 12) & 8191), T2 = s[5] + (k3 >>> 1 & 8191), N = s[6] + ((k3 >>> 14 | E2 << 2) & 8191), S2 = s[7] + ((E2 >>> 11 | B2 << 5) & 8191), U2 = s[8] + ((B2 >>> 8 | j << 8) & 8191), $ = s[9] + (j >>> 5 | o2), p2 = 0, C4 = p2 + v2 * c2 + I2 * (5 * m2) + w * (5 * h3) + R2 * (5 * y3) + A2 * (5 * g);
    p2 = C4 >>> 13, C4 &= 8191, C4 += T2 * (5 * d2) + N * (5 * f5) + S2 * (5 * l2) + U2 * (5 * a2) + $ * (5 * u2), p2 += C4 >>> 13, C4 &= 8191;
    let D = p2 + v2 * u2 + I2 * c2 + w * (5 * m2) + R2 * (5 * h3) + A2 * (5 * y3);
    p2 = D >>> 13, D &= 8191, D += T2 * (5 * g) + N * (5 * d2) + S2 * (5 * f5) + U2 * (5 * l2) + $ * (5 * a2), p2 += D >>> 13, D &= 8191;
    let P3 = p2 + v2 * a2 + I2 * u2 + w * c2 + R2 * (5 * m2) + A2 * (5 * h3);
    p2 = P3 >>> 13, P3 &= 8191, P3 += T2 * (5 * y3) + N * (5 * g) + S2 * (5 * d2) + U2 * (5 * f5) + $ * (5 * l2), p2 += P3 >>> 13, P3 &= 8191;
    let G2 = p2 + v2 * l2 + I2 * a2 + w * u2 + R2 * c2 + A2 * (5 * m2);
    p2 = G2 >>> 13, G2 &= 8191, G2 += T2 * (5 * h3) + N * (5 * y3) + S2 * (5 * g) + U2 * (5 * d2) + $ * (5 * f5), p2 += G2 >>> 13, G2 &= 8191;
    let X = p2 + v2 * f5 + I2 * l2 + w * a2 + R2 * u2 + A2 * c2;
    p2 = X >>> 13, X &= 8191, X += T2 * (5 * m2) + N * (5 * h3) + S2 * (5 * y3) + U2 * (5 * g) + $ * (5 * d2), p2 += X >>> 13, X &= 8191;
    let Z2 = p2 + v2 * d2 + I2 * f5 + w * l2 + R2 * a2 + A2 * u2;
    p2 = Z2 >>> 13, Z2 &= 8191, Z2 += T2 * c2 + N * (5 * m2) + S2 * (5 * h3) + U2 * (5 * y3) + $ * (5 * g), p2 += Z2 >>> 13, Z2 &= 8191;
    let he2 = p2 + v2 * g + I2 * d2 + w * f5 + R2 * l2 + A2 * a2;
    p2 = he2 >>> 13, he2 &= 8191, he2 += T2 * u2 + N * c2 + S2 * (5 * m2) + U2 * (5 * h3) + $ * (5 * y3), p2 += he2 >>> 13, he2 &= 8191;
    let pe = p2 + v2 * y3 + I2 * g + w * d2 + R2 * f5 + A2 * l2;
    p2 = pe >>> 13, pe &= 8191, pe += T2 * a2 + N * u2 + S2 * c2 + U2 * (5 * m2) + $ * (5 * h3), p2 += pe >>> 13, pe &= 8191;
    let ge = p2 + v2 * h3 + I2 * y3 + w * g + R2 * d2 + A2 * f5;
    p2 = ge >>> 13, ge &= 8191, ge += T2 * l2 + N * a2 + S2 * u2 + U2 * c2 + $ * (5 * m2), p2 += ge >>> 13, ge &= 8191;
    let ye = p2 + v2 * m2 + I2 * h3 + w * y3 + R2 * g + A2 * d2;
    p2 = ye >>> 13, ye &= 8191, ye += T2 * f5 + N * l2 + S2 * a2 + U2 * u2 + $ * c2, p2 += ye >>> 13, ye &= 8191, p2 = (p2 << 2) + p2 | 0, p2 = p2 + C4 | 0, C4 = p2 & 8191, p2 = p2 >>> 13, D += p2, s[0] = C4, s[1] = D, s[2] = P3, s[3] = G2, s[4] = X, s[5] = Z2, s[6] = he2, s[7] = pe, s[8] = ge, s[9] = ye;
  }
  finalize() {
    const { h: t, pad: n2 } = this, r2 = new Uint16Array(10);
    let o2 = t[1] >>> 13;
    t[1] &= 8191;
    for (let c2 = 2; c2 < 10; c2++) t[c2] += o2, o2 = t[c2] >>> 13, t[c2] &= 8191;
    t[0] += o2 * 5, o2 = t[0] >>> 13, t[0] &= 8191, t[1] += o2, o2 = t[1] >>> 13, t[1] &= 8191, t[2] += o2, r2[0] = t[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c2 = 1; c2 < 10; c2++) r2[c2] = t[c2] + o2, o2 = r2[c2] >>> 13, r2[c2] &= 8191;
    r2[9] -= 8192;
    let s = (o2 ^ 1) - 1;
    for (let c2 = 0; c2 < 10; c2++) r2[c2] &= s;
    s = ~s;
    for (let c2 = 0; c2 < 10; c2++) t[c2] = t[c2] & s | r2[c2];
    t[0] = (t[0] | t[1] << 13) & 65535, t[1] = (t[1] >>> 3 | t[2] << 10) & 65535, t[2] = (t[2] >>> 6 | t[3] << 7) & 65535, t[3] = (t[3] >>> 9 | t[4] << 4) & 65535, t[4] = (t[4] >>> 12 | t[5] << 1 | t[6] << 14) & 65535, t[5] = (t[6] >>> 2 | t[7] << 11) & 65535, t[6] = (t[7] >>> 5 | t[8] << 8) & 65535, t[7] = (t[8] >>> 8 | t[9] << 5) & 65535;
    let i3 = t[0] + n2[0];
    t[0] = i3 & 65535;
    for (let c2 = 1; c2 < 8; c2++) i3 = (t[c2] + n2[c2] | 0) + (i3 >>> 16) | 0, t[c2] = i3 & 65535;
    Ee(r2);
  }
  update(t) {
    Ln(this);
    const { buffer: n2, blockLen: r2 } = this;
    t = pt(t);
    const o2 = t.length;
    for (let s = 0; s < o2; ) {
      const i3 = Math.min(r2 - this.pos, o2 - s);
      if (i3 === r2) {
        for (; r2 <= o2 - s; s += r2) this.process(t, s);
        continue;
      }
      n2.set(t.subarray(s, s + i3), this.pos), this.pos += i3, s += i3, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t) {
    Ln(this), cs(t, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let s = 0;
    for (let i3 = 0; i3 < 8; i3++) t[s++] = r2[i3] >>> 0, t[s++] = r2[i3] >>> 8;
    return t;
  }
  digest() {
    const { buffer: t, outputLen: n2 } = this;
    this.digestInto(t);
    const r2 = t.slice(0, n2);
    return this.destroy(), r2;
  }
};
function Is(e) {
  const t = (r2, o2) => e(o2).update(pt(r2)).digest(), n2 = e(new Uint8Array(32));
  return t.outputLen = n2.outputLen, t.blockLen = n2.blockLen, t.create = (r2) => e(r2), t;
}
var Os = Is((e) => new xs(e));
function As(e, t, n2, r2, o2, s = 20) {
  let i3 = e[0], c2 = e[1], u2 = e[2], a2 = e[3], l2 = t[0], f5 = t[1], d2 = t[2], g = t[3], y3 = t[4], h3 = t[5], m2 = t[6], L = t[7], b2 = o2, _2 = n2[0], O3 = n2[1], k3 = n2[2], E2 = i3, B2 = c2, j = u2, v2 = a2, I2 = l2, w = f5, R2 = d2, A2 = g, T2 = y3, N = h3, S2 = m2, U2 = L, $ = b2, p2 = _2, C4 = O3, D = k3;
  for (let G2 = 0; G2 < s; G2 += 2) E2 = E2 + I2 | 0, $ = x($ ^ E2, 16), T2 = T2 + $ | 0, I2 = x(I2 ^ T2, 12), E2 = E2 + I2 | 0, $ = x($ ^ E2, 8), T2 = T2 + $ | 0, I2 = x(I2 ^ T2, 7), B2 = B2 + w | 0, p2 = x(p2 ^ B2, 16), N = N + p2 | 0, w = x(w ^ N, 12), B2 = B2 + w | 0, p2 = x(p2 ^ B2, 8), N = N + p2 | 0, w = x(w ^ N, 7), j = j + R2 | 0, C4 = x(C4 ^ j, 16), S2 = S2 + C4 | 0, R2 = x(R2 ^ S2, 12), j = j + R2 | 0, C4 = x(C4 ^ j, 8), S2 = S2 + C4 | 0, R2 = x(R2 ^ S2, 7), v2 = v2 + A2 | 0, D = x(D ^ v2, 16), U2 = U2 + D | 0, A2 = x(A2 ^ U2, 12), v2 = v2 + A2 | 0, D = x(D ^ v2, 8), U2 = U2 + D | 0, A2 = x(A2 ^ U2, 7), E2 = E2 + w | 0, D = x(D ^ E2, 16), S2 = S2 + D | 0, w = x(w ^ S2, 12), E2 = E2 + w | 0, D = x(D ^ E2, 8), S2 = S2 + D | 0, w = x(w ^ S2, 7), B2 = B2 + R2 | 0, $ = x($ ^ B2, 16), U2 = U2 + $ | 0, R2 = x(R2 ^ U2, 12), B2 = B2 + R2 | 0, $ = x($ ^ B2, 8), U2 = U2 + $ | 0, R2 = x(R2 ^ U2, 7), j = j + A2 | 0, p2 = x(p2 ^ j, 16), T2 = T2 + p2 | 0, A2 = x(A2 ^ T2, 12), j = j + A2 | 0, p2 = x(p2 ^ j, 8), T2 = T2 + p2 | 0, A2 = x(A2 ^ T2, 7), v2 = v2 + I2 | 0, C4 = x(C4 ^ v2, 16), N = N + C4 | 0, I2 = x(I2 ^ N, 12), v2 = v2 + I2 | 0, C4 = x(C4 ^ v2, 8), N = N + C4 | 0, I2 = x(I2 ^ N, 7);
  let P3 = 0;
  r2[P3++] = i3 + E2 | 0, r2[P3++] = c2 + B2 | 0, r2[P3++] = u2 + j | 0, r2[P3++] = a2 + v2 | 0, r2[P3++] = l2 + I2 | 0, r2[P3++] = f5 + w | 0, r2[P3++] = d2 + R2 | 0, r2[P3++] = g + A2 | 0, r2[P3++] = y3 + T2 | 0, r2[P3++] = h3 + N | 0, r2[P3++] = m2 + S2 | 0, r2[P3++] = L + U2 | 0, r2[P3++] = b2 + $ | 0, r2[P3++] = _2 + p2 | 0, r2[P3++] = O3 + C4 | 0, r2[P3++] = k3 + D | 0;
}
var Ns = vs(As, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ss = new Uint8Array(16);
var Hn = (e, t) => {
  e.update(t);
  const n2 = t.length % 16;
  n2 && e.update(Ss.subarray(n2));
};
var Us = new Uint8Array(32);
function Kn(e, t, n2, r2, o2) {
  const s = e(t, n2, Us), i3 = Os.create(s);
  o2 && Hn(i3, o2), Hn(i3, r2);
  const c2 = new Uint8Array(16), u2 = as(c2);
  kn(u2, 0, BigInt(o2 ? o2.length : 0), true), kn(u2, 8, BigInt(r2.length), true), i3.update(c2);
  const a2 = i3.digest();
  return Ee(s, c2), a2;
}
var _s = (e) => (t, n2, r2) => ({ encrypt(s, i3) {
  const c2 = s.length;
  i3 = Cn(c2 + 16, i3, false), i3.set(s);
  const u2 = i3.subarray(0, -16);
  e(t, n2, u2, u2, 1);
  const a2 = Kn(e, t, n2, u2, r2);
  return i3.set(a2, c2), Ee(a2), i3;
}, decrypt(s, i3) {
  i3 = Cn(s.length - 16, i3, false);
  const c2 = s.subarray(0, -16), u2 = s.subarray(-16), a2 = Kn(e, t, n2, c2, r2);
  if (!ds(u2, a2)) throw new Error("invalid tag");
  return i3.set(s.subarray(0, -16)), e(t, n2, i3, i3, 1), Ee(a2), i3;
} });
var Fn = hs({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _s(Ns));
var qn = class extends it {
  constructor(t, n2) {
    super(), this.finished = false, this.destroyed = false, ot(t);
    const r2 = we(n2);
    if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, s = new Uint8Array(o2);
    s.set(r2.length > o2 ? t.create().update(r2).digest() : r2);
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let i3 = 0; i3 < s.length; i3++) s[i3] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return me(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    me(this), je(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o2, destroyed: s, blockLen: i3, outputLen: c2 } = this;
    return t = t, t.finished = o2, t.destroyed = s, t.blockLen = i3, t.outputLen = c2, t.oHash = n2._cloneInto(t.oHash), t.iHash = r2._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var mt = (e, t, n2) => new qn(e, t).update(n2).digest();
mt.create = (e, t) => new qn(e, t);
var bt = new Uint8Array([0]);
var Gn = new Uint8Array();
function Ps(e, t, n2, r2) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n2, r2);
  const o2 = BigInt(32), s = BigInt(4294967295), i3 = Number(n2 >> o2 & s), c2 = Number(n2 & s), u2 = r2 ? 4 : 0, a2 = r2 ? 0 : 4;
  e.setUint32(t + u2, i3, r2), e.setUint32(t + a2, c2, r2);
}
function Bs(e, t, n2) {
  return e & t ^ ~e & n2;
}
function Ls(e, t, n2) {
  return e & t ^ e & n2 ^ t & n2;
}
var js = class extends it {
  constructor(t, n2, r2, o2) {
    super(), this.blockLen = t, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = st(this.buffer);
  }
  update(t) {
    me(this);
    const { view: n2, buffer: r2, blockLen: o2 } = this;
    t = we(t);
    const s = t.length;
    for (let i3 = 0; i3 < s; ) {
      const c2 = Math.min(o2 - this.pos, s - i3);
      if (c2 === o2) {
        const u2 = st(t);
        for (; o2 <= s - i3; i3 += o2) this.process(u2, i3);
        continue;
      }
      r2.set(t.subarray(i3, i3 + c2), this.pos), this.pos += c2, i3 += c2, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    me(this), sn2(t, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: s } = this;
    let { pos: i3 } = this;
    n2[i3++] = 128, this.buffer.subarray(i3).fill(0), this.padOffset > o2 - i3 && (this.process(r2, 0), i3 = 0);
    for (let f5 = i3; f5 < o2; f5++) n2[f5] = 0;
    Ps(r2, o2 - 8, BigInt(this.length * 8), s), this.process(r2, 0);
    const c2 = st(t), u2 = this.outputLen;
    if (u2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a2 = u2 / 4, l2 = this.get();
    if (a2 > l2.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f5 = 0; f5 < a2; f5++) c2.setUint32(4 * f5, l2[f5], s);
  }
  digest() {
    const { buffer: t, outputLen: n2 } = this;
    this.digestInto(t);
    const r2 = t.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: s, destroyed: i3, pos: c2 } = this;
    return t.length = o2, t.pos = c2, t.finished = s, t.destroyed = i3, o2 % n2 && t.buffer.set(r2), t;
  }
};
var Cs = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var ie = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var ce = new Uint32Array(64);
var ks = class extends js {
  constructor() {
    super(64, 32, 8, false), this.A = ie[0] | 0, this.B = ie[1] | 0, this.C = ie[2] | 0, this.D = ie[3] | 0, this.E = ie[4] | 0, this.F = ie[5] | 0, this.G = ie[6] | 0, this.H = ie[7] | 0;
  }
  get() {
    const { A: t, B: n2, C: r2, D: o2, E: s, F: i3, G: c2, H: u2 } = this;
    return [t, n2, r2, o2, s, i3, c2, u2];
  }
  set(t, n2, r2, o2, s, i3, c2, u2) {
    this.A = t | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = s | 0, this.F = i3 | 0, this.G = c2 | 0, this.H = u2 | 0;
  }
  process(t, n2) {
    for (let f5 = 0; f5 < 16; f5++, n2 += 4) ce[f5] = t.getUint32(n2, false);
    for (let f5 = 16; f5 < 64; f5++) {
      const d2 = ce[f5 - 15], g = ce[f5 - 2], y3 = J2(d2, 7) ^ J2(d2, 18) ^ d2 >>> 3, h3 = J2(g, 17) ^ J2(g, 19) ^ g >>> 10;
      ce[f5] = h3 + ce[f5 - 7] + y3 + ce[f5 - 16] | 0;
    }
    let { A: r2, B: o2, C: s, D: i3, E: c2, F: u2, G: a2, H: l2 } = this;
    for (let f5 = 0; f5 < 64; f5++) {
      const d2 = J2(c2, 6) ^ J2(c2, 11) ^ J2(c2, 25), g = l2 + d2 + Bs(c2, u2, a2) + Cs[f5] + ce[f5] | 0, h3 = (J2(r2, 2) ^ J2(r2, 13) ^ J2(r2, 22)) + Ls(r2, o2, s) | 0;
      l2 = a2, a2 = u2, u2 = c2, c2 = i3 + g | 0, i3 = s, s = o2, o2 = r2, r2 = g + h3 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, s = s + this.C | 0, i3 = i3 + this.D | 0, c2 = c2 + this.E | 0, u2 = u2 + this.F | 0, a2 = a2 + this.G | 0, l2 = l2 + this.H | 0, this.set(r2, o2, s, i3, c2, u2, a2, l2);
  }
  roundClean() {
    ce.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var He = fn(() => new ks());
var Wn = BigInt(0);
function wt(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function zn(e) {
  if (!wt(e)) throw new Error("Uint8Array expected");
}
var Ds = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ms(e) {
  zn(e);
  let t = "";
  for (let n2 = 0; n2 < e.length; n2++) t += Ds[e[n2]];
  return t;
}
function Vs(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Wn : BigInt("0x" + e);
}
var ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn(e) {
  if (e >= ee._0 && e <= ee._9) return e - ee._0;
  if (e >= ee.A && e <= ee.F) return e - (ee.A - 10);
  if (e >= ee.a && e <= ee.f) return e - (ee.a - 10);
}
function Yn(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n2 = t / 2;
  if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, s = 0; o2 < n2; o2++, s += 2) {
    const i3 = Jn(e.charCodeAt(s)), c2 = Jn(e.charCodeAt(s + 1));
    if (i3 === void 0 || c2 === void 0) {
      const u2 = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + u2 + '" at index ' + s);
    }
    r2[o2] = i3 * 16 + c2;
  }
  return r2;
}
function Xn(e) {
  return zn(e), Vs(Ms(Uint8Array.from(e).reverse()));
}
function Hs(e, t) {
  return Yn(e.toString(16).padStart(t * 2, "0"));
}
function Ks(e, t) {
  return Hs(e, t).reverse();
}
function Zn(e, t, n2) {
  let r2;
  if (typeof t == "string") try {
    r2 = Yn(t);
  } catch (s) {
    throw new Error(e + " must be hex string or Uint8Array, cause: " + s);
  }
  else if (wt(t)) r2 = Uint8Array.from(t);
  else throw new Error(e + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(e + " of length " + n2 + " expected, got " + o2);
  return r2;
}
var Et = (e) => typeof e == "bigint" && Wn <= e;
function Fs(e, t, n2) {
  return Et(e) && Et(t) && Et(n2) && t <= e && e < n2;
}
function Qn(e, t, n2, r2) {
  if (!Fs(t, n2, r2)) throw new Error("expected valid " + e + ": " + n2 + " <= n < " + r2 + ", got " + t);
}
var qs = { bigint: (e) => typeof e == "bigint", function: (e) => typeof e == "function", boolean: (e) => typeof e == "boolean", string: (e) => typeof e == "string", stringOrUint8Array: (e) => typeof e == "string" || wt(e), isSafeInteger: (e) => Number.isSafeInteger(e), array: (e) => Array.isArray(e), field: (e, t) => t.Fp.isValid(e), hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen) };
function Gs(e, t, n2 = {}) {
  const r2 = (o2, s, i3) => {
    const c2 = qs[s];
    if (typeof c2 != "function") throw new Error("invalid validator function");
    const u2 = e[o2];
    if (!(i3 && u2 === void 0) && !c2(u2, e)) throw new Error("param " + String(o2) + " is invalid. Expected " + s + ", got " + u2);
  };
  for (const [o2, s] of Object.entries(t)) r2(o2, s, false);
  for (const [o2, s] of Object.entries(n2)) r2(o2, s, true);
  return e;
}
var ve = BigInt(0);
var Ke = BigInt(1);
function er(e, t) {
  const n2 = e % t;
  return n2 >= ve ? n2 : t + n2;
}
function Ws(e, t, n2) {
  if (t < ve) throw new Error("invalid exponent, negatives unsupported");
  if (n2 <= ve) throw new Error("invalid modulus");
  if (n2 === Ke) return ve;
  let r2 = Ke;
  for (; t > ve; ) t & Ke && (r2 = r2 * e % n2), e = e * e % n2, t >>= Ke;
  return r2;
}
function z(e, t, n2) {
  let r2 = e;
  for (; t-- > ve; ) r2 *= r2, r2 %= n2;
  return r2;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var xe = BigInt(0);
var vt = BigInt(1);
function zs(e) {
  return Gs(e, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e });
}
function Js(e) {
  const t = zs(e), { P: n2 } = t, r2 = (b2) => er(b2, n2), o2 = t.montgomeryBits, s = Math.ceil(o2 / 8), i3 = t.nByteLength, c2 = t.adjustScalarBytes || ((b2) => b2), u2 = t.powPminus2 || ((b2) => Ws(b2, n2 - BigInt(2), n2));
  function a2(b2, _2, O3) {
    const k3 = r2(b2 * (_2 - O3));
    return _2 = r2(_2 - k3), O3 = r2(O3 + k3), [_2, O3];
  }
  const l2 = (t.a - BigInt(2)) / BigInt(4);
  function f5(b2, _2) {
    Qn("u", b2, xe, n2), Qn("scalar", _2, xe, n2);
    const O3 = _2, k3 = b2;
    let E2 = vt, B2 = xe, j = b2, v2 = vt, I2 = xe, w;
    for (let A2 = BigInt(o2 - 1); A2 >= xe; A2--) {
      const T2 = O3 >> A2 & vt;
      I2 ^= T2, w = a2(I2, E2, j), E2 = w[0], j = w[1], w = a2(I2, B2, v2), B2 = w[0], v2 = w[1], I2 = T2;
      const N = E2 + B2, S2 = r2(N * N), U2 = E2 - B2, $ = r2(U2 * U2), p2 = S2 - $, C4 = j + v2, D = j - v2, P3 = r2(D * N), G2 = r2(C4 * U2), X = P3 + G2, Z2 = P3 - G2;
      j = r2(X * X), v2 = r2(k3 * r2(Z2 * Z2)), E2 = r2(S2 * $), B2 = r2(p2 * (S2 + r2(l2 * p2)));
    }
    w = a2(I2, E2, j), E2 = w[0], j = w[1], w = a2(I2, B2, v2), B2 = w[0], v2 = w[1];
    const R2 = u2(B2);
    return r2(E2 * R2);
  }
  function d2(b2) {
    return Ks(r2(b2), s);
  }
  function g(b2) {
    const _2 = Zn("u coordinate", b2, s);
    return i3 === 32 && (_2[31] &= 127), Xn(_2);
  }
  function y3(b2) {
    const _2 = Zn("scalar", b2), O3 = _2.length;
    if (O3 !== s && O3 !== i3) {
      let k3 = "" + s + " or " + i3;
      throw new Error("invalid scalar, expected " + k3 + " bytes, got " + O3);
    }
    return Xn(c2(_2));
  }
  function h3(b2, _2) {
    const O3 = g(_2), k3 = y3(b2), E2 = f5(O3, k3);
    if (E2 === xe) throw new Error("invalid private or public key received");
    return d2(E2);
  }
  const m2 = d2(t.Gu);
  function L(b2) {
    return h3(b2, m2);
  }
  return { scalarMult: h3, scalarMultBase: L, getSharedSecret: (b2, _2) => h3(b2, _2), getPublicKey: (b2) => L(b2), utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) }, GuBytes: m2 };
}
var xt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var Ys = BigInt(1);
var tr = BigInt(2);
var Xs = BigInt(3);
var Zs = BigInt(5);
BigInt(8);
function Qs(e) {
  const t = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s = xt, c2 = e * e % s * e % s, u2 = z(c2, tr, s) * c2 % s, a2 = z(u2, Ys, s) * e % s, l2 = z(a2, Zs, s) * a2 % s, f5 = z(l2, t, s) * l2 % s, d2 = z(f5, n2, s) * f5 % s, g = z(d2, r2, s) * d2 % s, y3 = z(g, o2, s) * g % s, h3 = z(y3, o2, s) * g % s, m2 = z(h3, t, s) * l2 % s;
  return { pow_p_5_8: z(m2, tr, s) * e % s, b2: c2 };
}
function ei(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
var It = Js({ P: xt, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e) => {
  const t = xt, { pow_p_5_8: n2, b2: r2 } = Qs(e);
  return er(z(n2, Xs, t) * r2, t);
}, adjustScalarBytes: ei, randomBytes: Se });

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var ze2 = "wc";
var he = "core";
var B = `${ze2}@2:${he}:`;
var Hs2 = import_time2.FIVE_SECONDS * 1e3;
var Ht = "https://verify.walletconnect.org";
var ue = Ht;
var Yt2 = `${ue}/v3`;
function sr(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;
  for (var i3 = 0; i3 < r2.length; i3++) {
    var n2 = r2.charAt(i3), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = i3;
  }
  var a2 = r2.length, c2 = r2.charAt(0), h3 = Math.log(a2) / Math.log(256), u2 = Math.log(256) / Math.log(a2);
  function d2(l2) {
    if (l2 instanceof Uint8Array || (ArrayBuffer.isView(l2) ? l2 = new Uint8Array(l2.buffer, l2.byteOffset, l2.byteLength) : Array.isArray(l2) && (l2 = Uint8Array.from(l2))), !(l2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l2.length === 0) return "";
    for (var b2 = 0, x3 = 0, I2 = 0, D = l2.length; I2 !== D && l2[I2] === 0; ) I2++, b2++;
    for (var j = (D - I2) * u2 + 1 >>> 0, T2 = new Uint8Array(j); I2 !== D; ) {
      for (var q2 = l2[I2], J3 = 0, K2 = j - 1; (q2 !== 0 || J3 < x3) && K2 !== -1; K2--, J3++) q2 += 256 * T2[K2] >>> 0, T2[K2] = q2 % a2 >>> 0, q2 = q2 / a2 >>> 0;
      if (q2 !== 0) throw new Error("Non-zero carry");
      x3 = J3, I2++;
    }
    for (var H = j - x3; H !== j && T2[H] === 0; ) H++;
    for (var me2 = c2.repeat(b2); H < j; ++H) me2 += r2.charAt(T2[H]);
    return me2;
  }
  function g(l2) {
    if (typeof l2 != "string") throw new TypeError("Expected String");
    if (l2.length === 0) return new Uint8Array();
    var b2 = 0;
    if (l2[b2] !== " ") {
      for (var x3 = 0, I2 = 0; l2[b2] === c2; ) x3++, b2++;
      for (var D = (l2.length - b2) * h3 + 1 >>> 0, j = new Uint8Array(D); l2[b2]; ) {
        var T2 = t[l2.charCodeAt(b2)];
        if (T2 === 255) return;
        for (var q2 = 0, J3 = D - 1; (T2 !== 0 || q2 < I2) && J3 !== -1; J3--, q2++) T2 += a2 * j[J3] >>> 0, j[J3] = T2 % 256 >>> 0, T2 = T2 / 256 >>> 0;
        if (T2 !== 0) throw new Error("Non-zero carry");
        I2 = q2, b2++;
      }
      if (l2[b2] !== " ") {
        for (var K2 = D - I2; K2 !== D && j[K2] === 0; ) K2++;
        for (var H = new Uint8Array(x3 + (D - K2)), me2 = x3; K2 !== D; ) H[me2++] = j[K2++];
        return H;
      }
    }
  }
  function _2(l2) {
    var b2 = g(l2);
    if (b2) return b2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d2, decodeUnsafe: g, decode: _2 };
}
var rr2 = sr;
var nr = rr2;
var si2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var or = (r2) => new TextEncoder().encode(r2);
var ar = (r2) => new TextDecoder().decode(r2);
var cr = class {
  constructor(e, t, s) {
    this.name = e, this.prefix = t, this.baseEncode = s;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var hr = class {
  constructor(e, t, s) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ri2(this, e);
  }
};
var lr = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ri2(this, e);
  }
  decode(e) {
    const t = e[0], s = this.decoders[t];
    if (s) return s.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r2, e) => new lr({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var ur = class {
  constructor(e, t, s, i3) {
    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i3, this.encoder = new cr(e, t, s), this.decoder = new hr(e, t, i3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ee2 = ({ name: r2, prefix: e, encode: t, decode: s }) => new ur(r2, e, t, s);
var de2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: s, decode: i3 } = nr(t, e);
  return Ee2({ prefix: r2, name: e, encode: s, decode: (n2) => si2(i3(n2)) });
};
var dr = (r2, e, t, s) => {
  const i3 = {};
  for (let u2 = 0; u2 < e.length; ++u2) i3[e[u2]] = u2;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a2 = 0, c2 = 0, h3 = 0;
  for (let u2 = 0; u2 < n2; ++u2) {
    const d2 = i3[r2[u2]];
    if (d2 === void 0) throw new SyntaxError(`Non-${s} character`);
    c2 = c2 << t | d2, a2 += t, a2 >= 8 && (a2 -= 8, o2[h3++] = 255 & c2 >> a2);
  }
  if (a2 >= t || 255 & c2 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var gr = (r2, e, t) => {
  const s = e[e.length - 1] === "=", i3 = (1 << t) - 1;
  let n2 = "", o2 = 0, a2 = 0;
  for (let c2 = 0; c2 < r2.length; ++c2) for (a2 = a2 << 8 | r2[c2], o2 += 8; o2 > t; ) o2 -= t, n2 += e[i3 & a2 >> o2];
  if (o2 && (n2 += e[i3 & a2 << t - o2]), s) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var P2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: s }) => Ee2({ prefix: e, name: r2, encode(i3) {
  return gr(i3, s, t);
}, decode(i3) {
  return dr(i3, s, t, r2);
} });
var pr = Ee2({ prefix: "\0", name: "identity", encode: (r2) => ar(r2), decode: (r2) => or(r2) });
var yr = Object.freeze({ __proto__: null, identity: pr });
var br = P2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var mr = Object.freeze({ __proto__: null, base2: br });
var fr = P2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Dr2 = Object.freeze({ __proto__: null, base8: fr });
var vr = de2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var wr = Object.freeze({ __proto__: null, base10: vr });
var _r = P2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Er = P2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ir = Object.freeze({ __proto__: null, base16: _r, base16upper: Er });
var Tr = P2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Cr = P2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Pr = P2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Sr = P2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Rr = P2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Or = P2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Ar = P2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var xr = P2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Nr = P2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $r = Object.freeze({ __proto__: null, base32: Tr, base32upper: Cr, base32pad: Pr, base32padupper: Sr, base32hex: Rr, base32hexupper: Or, base32hexpad: Ar, base32hexpadupper: xr, base32z: Nr });
var zr2 = de2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Lr2 = de2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var kr = Object.freeze({ __proto__: null, base36: zr2, base36upper: Lr2 });
var jr = de2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Ur = de2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Mr = Object.freeze({ __proto__: null, base58btc: jr, base58flickr: Ur });
var Fr = P2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kr2 = P2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Br2 = P2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Vr = P2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var qr = Object.freeze({ __proto__: null, base64: Fr, base64pad: Kr2, base64url: Br2, base64urlpad: Vr });
var ni = Array.from("");
var Gr = ni.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Wr = ni.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Hr(r2) {
  return r2.reduce((e, t) => (e += Gr[t], e), "");
}
function Yr2(r2) {
  const e = [];
  for (const t of r2) {
    const s = Wr[t.codePointAt(0)];
    if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s);
  }
  return new Uint8Array(e);
}
var Jr2 = Ee2({ prefix: "", name: "base256emoji", encode: Hr, decode: Yr2 });
var Xr2 = Object.freeze({ __proto__: null, base256emoji: Jr2 });
var Zr = ai2;
var oi2 = 128;
var Qr2 = 127;
var en = ~Qr2;
var tn = Math.pow(2, 31);
function ai2(r2, e, t) {
  e = e || [], t = t || 0;
  for (var s = t; r2 >= tn; ) e[t++] = r2 & 255 | oi2, r2 /= 128;
  for (; r2 & en; ) e[t++] = r2 & 255 | oi2, r2 >>>= 7;
  return e[t] = r2 | 0, ai2.bytes = t - s + 1, e;
}
var sn3 = Fe2;
var rn = 128;
var ci2 = 127;
function Fe2(r2, s) {
  var t = 0, s = s || 0, i3 = 0, n2 = s, o2, a2 = r2.length;
  do {
    if (n2 >= a2) throw Fe2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += i3 < 28 ? (o2 & ci2) << i3 : (o2 & ci2) * Math.pow(2, i3), i3 += 7;
  } while (o2 >= rn);
  return Fe2.bytes = n2 - s, t;
}
var nn = Math.pow(2, 7);
var on = Math.pow(2, 14);
var an2 = Math.pow(2, 21);
var cn2 = Math.pow(2, 28);
var hn2 = Math.pow(2, 35);
var ln2 = Math.pow(2, 42);
var un2 = Math.pow(2, 49);
var dn2 = Math.pow(2, 56);
var gn2 = Math.pow(2, 63);
var pn2 = function(r2) {
  return r2 < nn ? 1 : r2 < on ? 2 : r2 < an2 ? 3 : r2 < cn2 ? 4 : r2 < hn2 ? 5 : r2 < ln2 ? 6 : r2 < un2 ? 7 : r2 < dn2 ? 8 : r2 < gn2 ? 9 : 10;
};
var yn = { encode: Zr, decode: sn3, encodingLength: pn2 };
var hi2 = yn;
var li2 = (r2, e, t = 0) => (hi2.encode(r2, e, t), e);
var ui2 = (r2) => hi2.encodingLength(r2);
var Ke2 = (r2, e) => {
  const t = e.byteLength, s = ui2(r2), i3 = s + ui2(t), n2 = new Uint8Array(i3 + t);
  return li2(r2, n2, 0), li2(t, n2, s), n2.set(e, i3), new bn(r2, t, e, n2);
};
var bn = class {
  constructor(e, t, s, i3) {
    this.code = e, this.size = t, this.digest = s, this.bytes = i3;
  }
};
var di2 = ({ name: r2, code: e, encode: t }) => new mn(r2, e, t);
var mn = class {
  constructor(e, t, s) {
    this.name = e, this.code = t, this.encode = s;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ke2(this.code, t) : t.then((s) => Ke2(this.code, s));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var fn2 = di2({ name: "sha2-256", code: 18, encode: gi("SHA-256") });
var Dn2 = di2({ name: "sha2-512", code: 19, encode: gi("SHA-512") });
var vn = Object.freeze({ __proto__: null, sha256: fn2, sha512: Dn2 });
var pi2 = 0;
var wn = "identity";
var yi = si2;
var _n = (r2) => Ke2(pi2, yi(r2));
var En = { code: pi2, name: wn, encode: yi, digest: _n };
var In = Object.freeze({ __proto__: null, identity: En });
new TextEncoder(), new TextDecoder();
var bi2 = { ...yr, ...mr, ...Dr2, ...wr, ...Ir, ...$r, ...kr, ...Mr, ...qr, ...Xr2 };
({ ...vn, ...In });
function Tn(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r2) : new Uint8Array(r2);
}
function mi2(r2, e, t, s) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: s } };
}
var fi2 = mi2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Be = mi2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Tn(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var Cn2 = { utf8: fi2, "utf-8": fi2, hex: bi2.base16, latin1: Be, ascii: Be, binary: Be, ...bi2 };

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time3 = __toESM(require_cjs());
var import_events4 = __toESM(require_events());
var De = "wc";
var Le = 2;
var ke = "client";
var we2 = `${De}@${Le}:${ke}:`;
var yt2 = "wc";
var wt2 = "auth";
var ae2 = `${yt2}@${1.5}:${wt2}:`;
var ce2 = `${ae2}:PUB_KEY`;

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var St = "wc";
var Dt = "universal_provider";
var _ = `${St}@2:${Dt}:`;
var et2 = "https://rpc.walletconnect.org/v1/";
var qt = `${et2}bundler`;

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-wallet/dist/esm/src/W3mFrameConstants.js
var DEFAULT_SDK_URL = "https://secure.walletconnect.org/sdk";
var SECURE_SITE_SDK = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_SDK_URL"] : void 0) || DEFAULT_SDK_URL;
var DEFAULT_LOG_LEVEL = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_DEFAULT_LOG_LEVEL"] : void 0) || "error";
var SECURE_SITE_SDK_VERSION = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_SDK_VERSION"] : void 0) || "4";
var W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "eth_getUserOperationReceipt",
    "eth_estimateUserOperationGas",
    "eth_getUserOperationByHash",
    "eth_supportedEntryPoints",
    "wallet_getAssets"
  ],
  NOT_SAFE_RPC_METHODS: [
    "personal_sign",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "solana_signMessage",
    "solana_signTransaction",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction",
    "wallet_sendCalls",
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    "eth_sendUserOperation"
  ],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AlertController.js
var state7 = proxy({
  message: "",
  variant: "info",
  open: false
});
var AlertController = {
  state: state7,
  subscribeKey(key, callback) {
    return subscribeKey(state7, key, callback);
  },
  open(message, variant) {
    const { debug } = OptionsController.state;
    const { shortMessage, longMessage } = message;
    if (debug) {
      state7.message = shortMessage;
      state7.variant = variant;
      state7.open = true;
    }
    if (longMessage) {
      console.error(typeof longMessage === "function" ? longMessage() : longMessage);
    }
  },
  close() {
    state7.open = false;
    state7.message = "";
    state7.variant = "info";
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var baseUrl2 = CoreHelperUtil.getAnalyticsUrl();
var api = new FetchUtil({ baseUrl: baseUrl2, clientId: null });
var excluded = ["MODAL_CREATED"];
var state8 = proxy({
  timestamp: Date.now(),
  reportedErrors: {},
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
var EventsController = {
  state: state8,
  subscribe(callback) {
    return subscribe(state8, () => callback(state8));
  },
  getSdkProperties() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      projectId,
      st: sdkType,
      sv: sdkVersion || "html-wagmi-4.2.2"
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      const address = AccountController.state.address;
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api.post({
        path: "/e",
        params: EventsController.getSdkProperties(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: { ...payload.data, address }
        }
      });
      state8.reportedErrors["FORBIDDEN"] = false;
    } catch (err) {
      const isForbiddenError = err instanceof Error && err.cause instanceof Response && err.cause.status === ConstantsUtil.HTTP_STATUS_CODES.FORBIDDEN && !state8.reportedErrors["FORBIDDEN"];
      if (isForbiddenError) {
        AlertController.open({
          shortMessage: "Invalid App Configuration",
          longMessage: `Origin ${isSafe() ? window.origin : "uknown"} not found on Allowlist - update configuration on cloud.reown.com`
        }, "error");
        state8.reportedErrors["FORBIDDEN"] = true;
      }
    }
  },
  sendEvent(data) {
    state8.timestamp = Date.now();
    state8.data = data;
    if (OptionsController.state.features?.analytics) {
      EventsController._sendAnalyticsEvent(state8);
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/SIWXUtil.js
var SIWXUtil = {
  getSIWX() {
    return OptionsController.state.siwx;
  },
  async initializeIfEnabled() {
    const siwx = OptionsController.state.siwx;
    const caipAddress = ChainController.getActiveCaipAddress();
    if (!(siwx && caipAddress)) {
      return;
    }
    const [namespace, chainId, address] = caipAddress.split(":");
    if (!ChainController.checkIfSupportedNetwork(namespace)) {
      return;
    }
    try {
      const sessions = await siwx.getSessions(`${namespace}:${chainId}`, address);
      if (sessions.length) {
        return;
      }
      await ModalController.open({
        view: "SIWXSignMessage"
      });
    } catch (error) {
      console.error("SIWXUtil:initializeIfEnabled", error);
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: this.getSIWXEventProperties()
      });
      await ConnectionController._getClient()?.disconnect().catch(console.error);
      RouterController.reset("Connect");
      SnackController.showError("A problem occurred while trying initialize authentication");
    }
  },
  async requestSignMessage() {
    const siwx = OptionsController.state.siwx;
    const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
    const network = ChainController.getActiveCaipNetwork();
    const client = ConnectionController._getClient();
    if (!siwx) {
      throw new Error("SIWX is not enabled");
    }
    if (!address) {
      throw new Error("No ActiveCaipAddress found");
    }
    if (!network) {
      throw new Error("No ActiveCaipNetwork or client found");
    }
    if (!client) {
      throw new Error("No ConnectionController client found");
    }
    try {
      const siwxMessage = await siwx.createMessage({
        chainId: network.caipNetworkId,
        accountAddress: address
      });
      const message = siwxMessage.toString();
      const connectorId = ConnectorController.getConnectorId(network.chainNamespace);
      if (connectorId === ConstantsUtil.CONNECTOR_ID.AUTH) {
        RouterController.pushTransactionStack({
          view: null,
          goBack: false,
          replace: true
        });
      }
      const signature = await client.signMessage(message);
      await siwx.addSession({
        data: siwxMessage,
        message,
        signature
      });
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_SUCCESS",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      const properties = this.getSIWXEventProperties();
      if (!ModalController.state.open || RouterController.state.view === "ApproveTransaction") {
        await ModalController.open({
          view: "SIWXSignMessage"
        });
      }
      if (properties.isSmartAccount) {
        SnackController.showError("This application might not support Smart Accounts");
      } else {
        SnackController.showError("Signature declined");
      }
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties
      });
      console.error("SWIXUtil:requestSignMessage", error);
    }
  },
  async cancelSignMessage() {
    try {
      const siwx = this.getSIWX();
      const isRequired = siwx?.getRequired?.();
      if (isRequired) {
        await ConnectionController.disconnect();
      } else {
        ModalController.close();
      }
      RouterController.reset("Connect");
      EventsController.sendEvent({
        event: "CLICK_CANCEL_SIWX",
        type: "track",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      console.error("SIWXUtil:cancelSignMessage", error);
    }
  },
  async getSessions() {
    const siwx = OptionsController.state.siwx;
    const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
    const network = ChainController.getActiveCaipNetwork();
    if (!(siwx && address && network)) {
      return [];
    }
    return siwx.getSessions(network.caipNetworkId, address);
  },
  async isSIWXCloseDisabled() {
    const siwx = this.getSIWX();
    if (siwx) {
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isSiwxSignMessage = RouterController.state.view === "SIWXSignMessage";
      if (isApproveSignScreen || isSiwxSignMessage) {
        return siwx.getRequired?.() && (await this.getSessions()).length === 0;
      }
    }
    return false;
  },
  async universalProviderAuthenticate({ universalProvider, chains, methods }) {
    const siwx = SIWXUtil.getSIWX();
    const namespaces = new Set(chains.map((chain) => chain.split(":")[0]));
    if (!siwx || namespaces.size !== 1 || !namespaces.has("eip155")) {
      return false;
    }
    const siwxMessage = await siwx.createMessage({
      chainId: ChainController.getActiveCaipNetwork()?.caipNetworkId || "",
      accountAddress: ""
    });
    const result = await universalProvider.authenticate({
      nonce: siwxMessage.nonce,
      domain: siwxMessage.domain,
      uri: siwxMessage.uri,
      exp: siwxMessage.expirationTime,
      iat: siwxMessage.issuedAt,
      nbf: siwxMessage.notBefore,
      requestId: siwxMessage.requestId,
      version: siwxMessage.version,
      resources: siwxMessage.resources,
      statement: siwxMessage.statement,
      chainId: siwxMessage.chainId,
      methods,
      // The first chainId is what is used for universal provider to build the message
      chains: [siwxMessage.chainId, ...chains.filter((chain) => chain !== siwxMessage.chainId)]
    });
    SnackController.showLoading("Authenticating...", { autoClose: false });
    AccountController.setConnectedWalletInfo({
      ...result.session.peer.metadata,
      name: result.session.peer.metadata.name,
      icon: result.session.peer.metadata.icons?.[0],
      type: "WALLET_CONNECT"
    }, Array.from(namespaces)[0]);
    if (result?.auths?.length) {
      const sessions = result.auths.map((cacao) => {
        const message = universalProvider.client.formatAuthMessage({
          request: cacao.p,
          iss: cacao.p.iss
        });
        return {
          data: {
            ...cacao.p,
            accountAddress: cacao.p.iss.split(":").slice(-1).join(""),
            chainId: cacao.p.iss.split(":").slice(2, 4).join(":"),
            uri: cacao.p.aud,
            version: cacao.p.version || siwxMessage.version,
            expirationTime: cacao.p.exp,
            issuedAt: cacao.p.iat,
            notBefore: cacao.p.nbf
          },
          message,
          signature: cacao.s.s,
          cacao
        };
      });
      try {
        await siwx.setSessions(sessions);
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_SUCCESS",
          properties: SIWXUtil.getSIWXEventProperties()
        });
      } catch (error) {
        console.error("SIWX:universalProviderAuth - failed to set sessions", error);
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_ERROR",
          properties: SIWXUtil.getSIWXEventProperties()
        });
        await universalProvider.disconnect().catch(console.error);
        throw error;
      } finally {
        SnackController.hide();
      }
    }
    return true;
  },
  getSIWXEventProperties() {
    return {
      network: ChainController.state.activeCaipNetwork?.caipNetworkId || "",
      isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    };
  },
  async clearSessions() {
    const siwx = this.getSIWX();
    if (siwx) {
      await siwx.setSessions([]);
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TransactionsController.js
var state9 = proxy({
  transactions: [],
  coinbaseTransactions: {},
  transactionsByYear: {},
  lastNetworkInView: void 0,
  loading: false,
  empty: false,
  next: void 0
});
var TransactionsController = {
  state: state9,
  subscribe(callback) {
    return subscribe(state9, () => callback(state9));
  },
  setLastNetworkInView(lastNetworkInView) {
    state9.lastNetworkInView = lastNetworkInView;
  },
  async fetchTransactions(accountAddress, onramp) {
    if (!accountAddress) {
      throw new Error("Transactions can't be fetched without an accountAddress");
    }
    state9.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        cursor: state9.next,
        onramp,
        // Coinbase transaction history state updates require the latest data
        cache: onramp === "coinbase" ? "no-cache" : void 0,
        chainId: ChainController.state.activeCaipNetwork?.caipNetworkId
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const sameChainTransactions = this.filterByConnectedChain(nonSpamTransactions);
      const filteredTransactions = [...state9.transactions, ...sameChainTransactions];
      state9.loading = false;
      if (onramp === "coinbase") {
        state9.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state9.coinbaseTransactions, response.data);
      } else {
        state9.transactions = filteredTransactions;
        state9.transactionsByYear = this.groupTransactionsByYearAndMonth(state9.transactionsByYear, sameChainTransactions);
      }
      state9.empty = filteredTransactions.length === 0;
      state9.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId: OptionsController.state.projectId,
          cursor: state9.next,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state9.loading = false;
      state9.empty = true;
      state9.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      const month = new Date(transaction.metadata.minedAt).getMonth();
      const yearTransactions = grouped[year] ?? {};
      const monthTransactions = yearTransactions[month] ?? [];
      const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
      grouped[year] = {
        ...yearTransactions,
        [month]: [...newMonthTransactions, transaction].sort((a2, b2) => new Date(b2.metadata.minedAt).getTime() - new Date(a2.metadata.minedAt).getTime())
      };
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => transfer.nft_info?.flags.is_spam === true);
      return !isAllSpam;
    });
  },
  filterByConnectedChain(transactions) {
    const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;
    const filteredTransactions = transactions.filter((transaction) => transaction.metadata.chain === chainId);
    return filteredTransactions;
  },
  clearCursor() {
    state9.next = void 0;
  },
  resetTransactions() {
    state9.transactions = [];
    state9.transactionsByYear = {};
    state9.lastNetworkInView = void 0;
    state9.loading = false;
    state9.empty = false;
    state9.next = void 0;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js
var state10 = proxy({
  wcError: false,
  buffering: false,
  status: "disconnected"
});
var wcConnectionPromise;
var ConnectionController = {
  state: state10,
  subscribeKey(key, callback) {
    return subscribeKey(state10, key, callback);
  },
  _getClient() {
    return state10._client;
  },
  setClient(client) {
    state10._client = ref(client);
  },
  async connectWalletConnect() {
    if (CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari() && CoreHelperUtil.isIos()) {
      if (wcConnectionPromise) {
        await wcConnectionPromise;
        wcConnectionPromise = void 0;
        return;
      }
      if (!CoreHelperUtil.isPairingExpired(state10?.wcPairingExpiry)) {
        const link = state10.wcUri;
        state10.wcUri = link;
        return;
      }
      wcConnectionPromise = this._getClient()?.connectWalletConnect?.().catch(() => void 0);
      this.state.status = "connecting";
      await wcConnectionPromise;
      wcConnectionPromise = void 0;
      state10.wcPairingExpiry = void 0;
      this.state.status = "connected";
    } else {
      await this._getClient()?.connectWalletConnect?.();
    }
  },
  async connectExternal(options, chain, setChain = true) {
    await this._getClient()?.connectExternal?.(options);
    if (setChain) {
      ChainController.setActiveNamespace(chain);
    }
  },
  async reconnectExternal(options) {
    await this._getClient()?.reconnectExternal?.(options);
    const namespace = options.chain || ChainController.state.activeChain;
    if (namespace) {
      ConnectorController.setConnectorId(options.id, namespace);
    }
  },
  async setPreferredAccountType(accountType) {
    ModalController.setLoading(true, ChainController.state.activeChain);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    await authConnector?.provider.setPreferredAccount(accountType);
    await this.reconnectExternal(authConnector);
    ModalController.setLoading(false, ChainController.state.activeChain);
    EventsController.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: {
        accountType,
        network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
      }
    });
  },
  async signMessage(message) {
    return this._getClient()?.signMessage(message);
  },
  parseUnits(value, decimals) {
    return this._getClient()?.parseUnits(value, decimals);
  },
  formatUnits(value, decimals) {
    return this._getClient()?.formatUnits(value, decimals);
  },
  async sendTransaction(args) {
    return this._getClient()?.sendTransaction(args);
  },
  async getCapabilities(params) {
    return this._getClient()?.getCapabilities(params);
  },
  async grantPermissions(params) {
    return this._getClient()?.grantPermissions(params);
  },
  async walletGetAssets(params) {
    return this._getClient()?.walletGetAssets(params) ?? {};
  },
  async estimateGas(args) {
    return this._getClient()?.estimateGas(args);
  },
  async writeContract(args) {
    return this._getClient()?.writeContract(args);
  },
  async getEnsAddress(value) {
    return this._getClient()?.getEnsAddress(value);
  },
  async getEnsAvatar(value) {
    return this._getClient()?.getEnsAvatar(value);
  },
  checkInstalled(ids) {
    return this._getClient()?.checkInstalled?.(ids) || false;
  },
  resetWcConnection() {
    state10.wcUri = void 0;
    state10.wcPairingExpiry = void 0;
    state10.wcLinking = void 0;
    state10.recentWallet = void 0;
    state10.status = "disconnected";
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  resetUri() {
    state10.wcUri = void 0;
    state10.wcPairingExpiry = void 0;
  },
  finalizeWcConnection() {
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: RouterController.state.data?.wallet?.name || "Unknown"
      }
    });
  },
  setWcBasic(wcBasic) {
    state10.wcBasic = wcBasic;
  },
  setUri(uri) {
    state10.wcUri = uri;
    state10.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
  },
  setWcLinking(wcLinking) {
    state10.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state10.wcError = wcError;
    state10.buffering = false;
  },
  setRecentWallet(wallet) {
    state10.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state10.buffering = buffering;
  },
  setStatus(status) {
    state10.status = status;
  },
  async disconnect(namespace) {
    try {
      ModalController.setLoading(true, namespace);
      await SIWXUtil.clearSessions();
      await ChainController.disconnect(namespace);
      ModalController.setLoading(false, namespace);
      ConnectorController.setFilterByNamespace(void 0);
    } catch (error) {
      throw new Error("Failed to disconnect");
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/PublicStateController.js
var state11 = proxy({
  loading: false,
  open: false,
  selectedNetworkId: void 0,
  activeChain: void 0,
  initialized: false
});
var PublicStateController = {
  state: state11,
  subscribe(callback) {
    return subscribe(state11, () => callback(state11));
  },
  set(newState) {
    Object.assign(state11, { ...state11, ...newState });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js
var state12 = proxy({
  loading: false,
  loadingNamespaceMap: /* @__PURE__ */ new Map(),
  open: false,
  shake: false,
  namespace: void 0
});
var ModalController = {
  state: state12,
  subscribe(callback) {
    return subscribe(state12, () => callback(state12));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state12, key, callback);
  },
  async open(options) {
    const isConnected = AccountController.state.status === "connected";
    if (ConnectionController.state.wcBasic) {
      ApiController.prefetch({ fetchNetworkImages: false, fetchConnectorImages: false });
    } else {
      await ApiController.prefetch({
        fetchConnectorImages: !isConnected,
        fetchFeaturedWallets: !isConnected,
        fetchRecommendedWallets: !isConnected
      });
    }
    if (options?.namespace) {
      await ChainController.switchActiveNamespace(options.namespace);
      ModalController.setLoading(true, options.namespace);
    } else {
      ModalController.setLoading(true);
    }
    ConnectorController.setFilterByNamespace(options?.namespace);
    const caipAddress = ChainController.getAccountData(options?.namespace)?.caipAddress;
    const hasNoAdapters = ChainController.state.noAdapters;
    if (hasNoAdapters && !caipAddress) {
      if (CoreHelperUtil.isMobile()) {
        RouterController.reset("AllWallets");
      } else {
        RouterController.reset("ConnectingWalletConnectBasic");
      }
    } else if (options?.view) {
      RouterController.reset(options.view);
    } else if (caipAddress) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state12.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected: Boolean(caipAddress) }
    });
  },
  close() {
    const isEmbeddedEnabled = OptionsController.state.enableEmbedded;
    const isConnected = Boolean(ChainController.state.activeCaipAddress);
    if (state12.open) {
      EventsController.sendEvent({
        type: "track",
        event: "MODAL_CLOSE",
        properties: { connected: isConnected }
      });
    }
    state12.open = false;
    ModalController.clearLoading();
    if (isEmbeddedEnabled) {
      if (isConnected) {
        RouterController.replace("Account");
      } else {
        RouterController.push("Connect");
      }
    } else {
      PublicStateController.set({ open: false });
    }
    ConnectionController.resetUri();
  },
  setLoading(loading, namespace) {
    if (namespace) {
      state12.loadingNamespaceMap.set(namespace, loading);
    }
    state12.loading = loading;
    PublicStateController.set({ loading });
  },
  clearLoading() {
    state12.loadingNamespaceMap.clear();
    state12.loading = false;
  },
  shake() {
    if (state12.shake) {
      return;
    }
    state12.shake = true;
    setTimeout(() => {
      state12.shake = false;
    }, 500);
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var state13 = proxy({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
});
var RouterController = {
  state: state13,
  subscribeKey(key, callback) {
    return subscribeKey(state13, key, callback);
  },
  pushTransactionStack(action) {
    state13.transactionStack.push(action);
  },
  popTransactionStack(cancel) {
    const action = state13.transactionStack.pop();
    if (!action) {
      return;
    }
    if (cancel) {
      this.goBack();
      action?.onCancel?.();
    } else {
      if (action.goBack) {
        this.goBack();
      } else if (action.replace) {
        const history = state13.history;
        const connectingSiweIndex = history.indexOf("ConnectingSiwe");
        if (connectingSiweIndex > 0) {
          this.goBackToIndex(connectingSiweIndex - 1);
        } else {
          ModalController.close();
          state13.history = [];
        }
      } else if (action.view) {
        this.reset(action.view);
      }
      action?.onSuccess?.();
    }
  },
  push(view, data) {
    if (view !== state13.view) {
      state13.view = view;
      state13.history.push(view);
      state13.data = data;
    }
  },
  reset(view, data) {
    state13.view = view;
    state13.history = [view];
    state13.data = data;
  },
  replace(view, data) {
    const lastView = state13.history.at(-1);
    const isSameView = lastView === view;
    if (!isSameView) {
      state13.view = view;
      state13.history[state13.history.length - 1] = view;
      state13.data = data;
    }
  },
  goBack() {
    const shouldReload = !ChainController.state.activeCaipAddress && this.state.view === "ConnectingFarcaster";
    if (state13.history.length > 1 && !state13.history.includes("UnsupportedChain")) {
      state13.history.pop();
      const [last] = state13.history.slice(-1);
      if (last) {
        state13.view = last;
      }
    } else {
      ModalController.close();
    }
    if (state13.data?.wallet) {
      state13.data.wallet = void 0;
    }
    setTimeout(() => {
      if (shouldReload) {
        AccountController.setFarcasterUrl(void 0, ChainController.state.activeChain);
        const authConnector = ConnectorController.getAuthConnector();
        authConnector?.provider?.reload();
        const optionsState = snapshot(OptionsController.state);
        authConnector?.provider?.syncDappData?.({
          metadata: optionsState.metadata,
          sdkVersion: optionsState.sdkVersion,
          projectId: optionsState.projectId,
          sdkType: optionsState.sdkType
        });
      }
    }, 100);
  },
  goBackToIndex(historyIndex) {
    if (state13.history.length > 1) {
      state13.history = state13.history.slice(0, historyIndex + 1);
      const [last] = state13.history.slice(-1);
      if (last) {
        state13.view = last;
      }
    }
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ThemeController.js
var state14 = proxy({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
});
var ThemeController = {
  state: state14,
  subscribe(callback) {
    return subscribe(state14, () => callback(state14));
  },
  setThemeMode(themeMode) {
    state14.themeMode = themeMode;
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(themeVariables) {
    state14.themeVariables = { ...state14.themeVariables, ...themeVariables };
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariablesSnapshot = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeVariables: themeVariablesSnapshot,
          w3mThemeVariables: getW3mThemeVariables(state14.themeVariables, state14.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return snapshot(state14);
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var defaultActiveConnectors = {
  eip155: void 0,
  solana: void 0,
  polkadot: void 0,
  bip122: void 0
};
var state15 = proxy({
  allConnectors: [],
  connectors: [],
  activeConnector: void 0,
  filterByNamespace: void 0,
  activeConnectorIds: { ...defaultActiveConnectors }
});
var ConnectorController = {
  state: state15,
  subscribe(callback) {
    return subscribe(state15, () => {
      callback(state15);
    });
  },
  subscribeKey(key, callback) {
    return subscribeKey(state15, key, callback);
  },
  initialize(namespaces) {
    namespaces.forEach((namespace) => {
      const connectorId = StorageUtil.getConnectedConnectorId(namespace);
      if (connectorId) {
        this.setConnectorId(connectorId, namespace);
      }
    });
  },
  setActiveConnector(connector) {
    if (connector) {
      state15.activeConnector = ref(connector);
    }
  },
  setConnectors(connectors) {
    const newConnectors = connectors.filter((newConnector) => !state15.allConnectors.some((existingConnector) => existingConnector.id === newConnector.id && this.getConnectorName(existingConnector.name) === this.getConnectorName(newConnector.name) && existingConnector.chain === newConnector.chain));
    newConnectors.forEach((connector) => {
      if (connector.type !== "MULTI_CHAIN") {
        state15.allConnectors.push(ref(connector));
      }
    });
    state15.connectors = this.mergeMultiChainConnectors(state15.allConnectors);
  },
  removeAdapter(namespace) {
    state15.allConnectors = state15.allConnectors.filter((connector) => connector.chain !== namespace);
    state15.connectors = this.mergeMultiChainConnectors(state15.allConnectors);
  },
  mergeMultiChainConnectors(connectors) {
    const connectorsByNameMap = this.generateConnectorMapByName(connectors);
    const mergedConnectors = [];
    connectorsByNameMap.forEach((keyConnectors) => {
      const firstItem = keyConnectors[0];
      const isAuthConnector = firstItem?.id === ConstantsUtil.CONNECTOR_ID.AUTH;
      if (keyConnectors.length > 1 && firstItem) {
        mergedConnectors.push({
          name: firstItem.name,
          imageUrl: firstItem.imageUrl,
          imageId: firstItem.imageId,
          connectors: [...keyConnectors],
          type: isAuthConnector ? "AUTH" : "MULTI_CHAIN",
          // These values are just placeholders, we don't use them in multi-chain connector select screen
          chain: "eip155",
          id: firstItem?.id || ""
        });
      } else if (firstItem) {
        mergedConnectors.push(firstItem);
      }
    });
    return mergedConnectors;
  },
  generateConnectorMapByName(connectors) {
    const connectorsByNameMap = /* @__PURE__ */ new Map();
    connectors.forEach((connector) => {
      const { name } = connector;
      const connectorName = this.getConnectorName(name);
      if (!connectorName) {
        return;
      }
      const connectorsByName = connectorsByNameMap.get(connectorName) || [];
      const haveSameConnector = connectorsByName.find((c2) => c2.chain === connector.chain);
      if (!haveSameConnector) {
        connectorsByName.push(connector);
      }
      connectorsByNameMap.set(connectorName, connectorsByName);
    });
    return connectorsByNameMap;
  },
  getConnectorName(name) {
    if (!name) {
      return name;
    }
    const nameOverrideMap = {
      "Trust Wallet": "Trust"
    };
    return nameOverrideMap[name] || name;
  },
  getUniqueConnectorsByName(connectors) {
    const uniqueConnectors = [];
    connectors.forEach((c2) => {
      if (!uniqueConnectors.find((uc) => uc.chain === c2.chain)) {
        uniqueConnectors.push(c2);
      }
    });
    return uniqueConnectors;
  },
  addConnector(connector) {
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const authConnector = connector;
      const optionsState = snapshot(OptionsController.state);
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      authConnector?.provider?.syncDappData?.({
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId,
        sdkType: optionsState.sdkType
      });
      authConnector?.provider?.syncTheme({
        themeMode,
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
      this.setConnectors([connector]);
    } else {
      this.setConnectors([connector]);
    }
  },
  getAuthConnector(chainNamespace) {
    const activeNamespace = chainNamespace || ChainController.state.activeChain;
    const authConnector = state15.connectors.find((c2) => c2.id === ConstantsUtil.CONNECTOR_ID.AUTH);
    if (!authConnector) {
      return void 0;
    }
    if (authConnector?.connectors?.length) {
      const connector = authConnector.connectors.find((c2) => c2.chain === activeNamespace);
      return connector;
    }
    return authConnector;
  },
  getAnnouncedConnectorRdns() {
    return state15.connectors.filter((c2) => c2.type === "ANNOUNCED").map((c2) => c2.info?.rdns);
  },
  getConnectorById(id) {
    return state15.allConnectors.find((c2) => c2.id === id);
  },
  getConnector(id, rdns) {
    const connectorsByNamespace = state15.allConnectors.filter((c2) => c2.chain === ChainController.state.activeChain);
    return connectorsByNamespace.find((c2) => c2.explorerId === id || c2.info?.rdns === rdns);
  },
  syncIfAuthConnector(connector) {
    if (connector.id !== "ID_AUTH") {
      return;
    }
    const authConnector = connector;
    const optionsState = snapshot(OptionsController.state);
    const themeMode = ThemeController.getSnapshot().themeMode;
    const themeVariables = ThemeController.getSnapshot().themeVariables;
    authConnector?.provider?.syncDappData?.({
      metadata: optionsState.metadata,
      sdkVersion: optionsState.sdkVersion,
      sdkType: optionsState.sdkType,
      projectId: optionsState.projectId
    });
    authConnector.provider.syncTheme({
      themeMode,
      themeVariables,
      w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
    });
  },
  /**
   * Returns the connectors filtered by namespace.
   * @param namespace - The namespace to filter the connectors by.
   * @returns ConnectorWithProviders[].
   */
  getConnectorsByNamespace(namespace) {
    const namespaceConnectors = state15.allConnectors.filter((connector) => connector.chain === namespace);
    return this.mergeMultiChainConnectors(namespaceConnectors);
  },
  selectWalletConnector(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA) {
      MobileWalletUtil.handleSolanaDeeplinkRedirect(connector?.name || wallet.name || "");
    }
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  },
  /**
   * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.
   * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.
   * @returns ConnectorWithProviders[].
   */
  getConnectors(namespace) {
    if (namespace) {
      return this.getConnectorsByNamespace(namespace);
    }
    return this.mergeMultiChainConnectors(state15.allConnectors);
  },
  /**
   * Sets the filter by namespace and updates the connectors.
   * @param namespace - The namespace to filter the connectors by.
   */
  setFilterByNamespace(namespace) {
    state15.filterByNamespace = namespace;
    state15.connectors = this.getConnectors(namespace);
    ApiController.setFilterByNamespace(namespace);
  },
  setConnectorId(connectorId, namespace) {
    if (connectorId) {
      state15.activeConnectorIds = {
        ...state15.activeConnectorIds,
        [namespace]: connectorId
      };
      StorageUtil.setConnectedConnectorId(namespace, connectorId);
    }
  },
  removeConnectorId(namespace) {
    state15.activeConnectorIds = {
      ...state15.activeConnectorIds,
      [namespace]: void 0
    };
    StorageUtil.deleteConnectedConnectorId(namespace);
  },
  getConnectorId(namespace) {
    if (!namespace) {
      return void 0;
    }
    return state15.activeConnectorIds[namespace];
  },
  isConnected(namespace) {
    if (!namespace) {
      return Object.values(state15.activeConnectorIds).some((id) => Boolean(id));
    }
    return Boolean(state15.activeConnectorIds[namespace]);
  },
  resetConnectorIds() {
    state15.activeConnectorIds = { ...defaultActiveConnectors };
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js
function checkNamespaceConnectorId(namespace, connectorId) {
  return ConnectorController.getConnectorId(namespace) === connectorId;
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js
function getChainsToDisconnect(namespace) {
  const namespaces = Array.from(ChainController.state.chains.keys());
  let chains = [];
  if (namespace) {
    chains.push([namespace, ChainController.state.chains.get(namespace)]);
    if (checkNamespaceConnectorId(namespace, ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)) {
      namespaces.forEach((ns) => {
        if (ns !== namespace && checkNamespaceConnectorId(ns, ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)) {
          chains.push([ns, ChainController.state.chains.get(ns)]);
        }
      });
    } else if (checkNamespaceConnectorId(namespace, ConstantsUtil.CONNECTOR_ID.AUTH)) {
      namespaces.forEach((ns) => {
        if (ns !== namespace && checkNamespaceConnectorId(ns, ConstantsUtil.CONNECTOR_ID.AUTH)) {
          chains.push([ns, ChainController.state.chains.get(ns)]);
        }
      });
    }
  } else {
    chains = Array.from(ChainController.state.chains.entries());
  }
  return chains;
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/ERC7811Util.js
var ERC7811Utils = {
  /**
   * Creates a Balance object from an ERC7811 Asset object
   * @param asset - Asset object to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns Balance object
   */
  createBalance(asset, chainId) {
    const metadata = {
      name: asset.metadata["name"] || "",
      symbol: asset.metadata["symbol"] || "",
      decimals: asset.metadata["decimals"] || 0,
      value: asset.metadata["value"] || 0,
      price: asset.metadata["price"] || 0,
      iconUrl: asset.metadata["iconUrl"] || ""
    };
    return {
      name: metadata.name,
      symbol: metadata.symbol,
      chainId,
      address: asset.address === "native" ? void 0 : this.convertAddressToCAIP10Address(asset.address, chainId),
      value: metadata.value,
      price: metadata.price,
      quantity: {
        decimals: metadata.decimals.toString(),
        numeric: this.convertHexToBalance({
          hex: asset.balance,
          decimals: metadata.decimals
        })
      },
      iconUrl: metadata.iconUrl
    };
  },
  /**
   * Converts a hex string to a Balance object
   * @param hex - Hex string to convert
   * @param decimals - Number of decimals to use
   * @returns Balance object
   */
  convertHexToBalance({ hex, decimals }) {
    return formatUnits(BigInt(hex), decimals);
  },
  /**
   * Converts an address to a CAIP-10 address
   * @param address - Address to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns CAIP-10 address
   */
  convertAddressToCAIP10Address(address, chainId) {
    return `${chainId}:${address}`;
  },
  /**
   *  Creates a CAIP-2 Chain ID from a chain ID and namespace
   * @param chainId  - Chain ID in hex format
   * @param namespace  - Chain namespace
   * @returns
   */
  createCAIP2ChainId(chainId, namespace) {
    return `${namespace}:${parseInt(chainId, 16)}`;
  },
  /**
   * Gets the chain ID in hex format from a CAIP-2 Chain ID
   * @param caip2ChainId - CAIP-2 Chain ID
   * @returns Chain ID in hex format
   */
  getChainIdHexFromCAIP2ChainId(caip2ChainId) {
    const parts = caip2ChainId.split(":");
    if (parts.length < 2 || !parts[1]) {
      return "0x0";
    }
    const chainPart = parts[1];
    const parsed = parseInt(chainPart, 10);
    return isNaN(parsed) ? "0x0" : `0x${parsed.toString(16)}`;
  },
  /**
   * Checks if a response is a valid WalletGetAssetsResponse
   * @param response - The response to check
   * @returns True if the response is a valid WalletGetAssetsResponse, false otherwise
   */
  isWalletGetAssetsResponse(response) {
    if (typeof response !== "object" || response === null) {
      return false;
    }
    return Object.values(response).every((value) => Array.isArray(value) && value.every((asset) => this.isValidAsset(asset)));
  },
  /**
   * Checks if an asset object is valid.
   * @param asset - The asset object to check.
   * @returns True if the asset is valid, false otherwise.
   */
  isValidAsset(asset) {
    return typeof asset === "object" && asset !== null && typeof asset.address === "string" && typeof asset.balance === "string" && (asset.type === "ERC20" || asset.type === "NATIVE") && typeof asset.metadata === "object" && asset.metadata !== null && typeof asset.metadata["name"] === "string" && typeof asset.metadata["symbol"] === "string" && typeof asset.metadata["decimals"] === "number" && typeof asset.metadata["price"] === "number" && typeof asset.metadata["iconUrl"] === "string";
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/SendApiUtil.js
var SendApiUtil = {
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!address || !caipNetwork) {
      return [];
    }
    if (caipNetwork.chainNamespace === "eip155") {
      const eip155Balances = await this.getEIP155Balances(address, caipNetwork);
      if (eip155Balances) {
        return this.filterLowQualityTokens(eip155Balances);
      }
    }
    const response = await BlockchainApiController.getBalance(address, caipNetwork.caipNetworkId, forceUpdate);
    return this.filterLowQualityTokens(response.balances);
  },
  async getEIP155Balances(address, caipNetwork) {
    try {
      const chainIdHex = ERC7811Utils.getChainIdHexFromCAIP2ChainId(caipNetwork.caipNetworkId);
      const walletCapabilities = await ConnectionController.getCapabilities(address);
      if (!walletCapabilities?.[chainIdHex]?.["assetDiscovery"]?.supported) {
        return null;
      }
      const walletGetAssetsResponse = await ConnectionController.walletGetAssets({
        account: address,
        chainFilter: [chainIdHex]
      });
      if (!ERC7811Utils.isWalletGetAssetsResponse(walletGetAssetsResponse)) {
        return null;
      }
      const assets = walletGetAssetsResponse[chainIdHex] || [];
      return assets.map((asset) => ERC7811Utils.createBalance(asset, caipNetwork.caipNetworkId));
    } catch (error) {
      return null;
    }
  },
  /**
   * The 1Inch API includes many low-quality tokens in the balance response,
   * which appear inconsistently. This filter prevents them from being displayed.
   */
  filterLowQualityTokens(balances) {
    return balances.filter((balance) => balance.quantity.decimals !== "0");
  },
  mapBalancesToSwapTokens(balances) {
    return balances?.map((token) => ({
      ...token,
      address: token?.address ? token.address : ChainController.getActiveNetworkTokenAddress(),
      decimals: parseInt(token.quantity.decimals, 10),
      logoUri: token.iconUrl,
      eip2612: false
    })) || [];
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js
var state16 = proxy({
  tokenBalances: [],
  loading: false
});
var SendController = {
  state: state16,
  subscribe(callback) {
    return subscribe(state16, () => callback(state16));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state16, key, callback);
  },
  setToken(token) {
    if (token) {
      state16.token = ref(token);
    }
  },
  setTokenAmount(sendTokenAmount) {
    state16.sendTokenAmount = sendTokenAmount;
  },
  setReceiverAddress(receiverAddress) {
    state16.receiverAddress = receiverAddress;
  },
  setReceiverProfileImageUrl(receiverProfileImageUrl) {
    state16.receiverProfileImageUrl = receiverProfileImageUrl;
  },
  setReceiverProfileName(receiverProfileName) {
    state16.receiverProfileName = receiverProfileName;
  },
  setGasPrice(gasPrice) {
    state16.gasPrice = gasPrice;
  },
  setGasPriceInUsd(gasPriceInUSD) {
    state16.gasPriceInUSD = gasPriceInUSD;
  },
  setNetworkBalanceInUsd(networkBalanceInUSD) {
    state16.networkBalanceInUSD = networkBalanceInUSD;
  },
  setLoading(loading) {
    state16.loading = loading;
  },
  sendToken() {
    switch (ChainController.state.activeCaipNetwork?.chainNamespace) {
      case "eip155":
        this.sendEvmToken();
        return;
      case "solana":
        this.sendSolanaToken();
        return;
      default:
        throw new Error("Unsupported chain");
    }
  },
  sendEvmToken() {
    if (this.state.token?.address && this.state.sendTokenAmount && this.state.receiverAddress) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token.address,
          amount: this.state.sendTokenAmount,
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
        }
      });
      this.sendERC20Token({
        receiverAddress: this.state.receiverAddress,
        tokenAddress: this.state.token.address,
        sendTokenAmount: this.state.sendTokenAmount,
        decimals: this.state.token.quantity.decimals
      });
    } else if (this.state.receiverAddress && this.state.sendTokenAmount && this.state.gasPrice && this.state.token?.quantity.decimals) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol,
          amount: this.state.sendTokenAmount,
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
        }
      });
      this.sendNativeToken({
        receiverAddress: this.state.receiverAddress,
        sendTokenAmount: this.state.sendTokenAmount,
        gasPrice: this.state.gasPrice,
        decimals: this.state.token.quantity.decimals
      });
    }
  },
  async fetchTokenBalance(onError) {
    state16.loading = true;
    const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;
    const chain = ChainController.state.activeCaipNetwork?.chainNamespace;
    const caipAddress = ChainController.state.activeCaipAddress;
    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (state16.lastRetry && !CoreHelperUtil.isAllowedRetry(state16.lastRetry, 30 * ConstantsUtil2.ONE_SEC_MS)) {
      state16.loading = false;
      return [];
    }
    try {
      if (address && chainId && chain) {
        const balances = await SendApiUtil.getMyTokensWithBalance();
        state16.tokenBalances = balances;
        state16.lastRetry = void 0;
        return balances;
      }
    } catch (error) {
      state16.lastRetry = Date.now();
      onError?.(error);
      SnackController.showError("Token Balance Unavailable");
    } finally {
      state16.loading = false;
    }
    return [];
  },
  fetchNetworkBalance() {
    if (state16.tokenBalances.length === 0) {
      return;
    }
    const networkTokenBalances = SendApiUtil.mapBalancesToSwapTokens(state16.tokenBalances);
    if (!networkTokenBalances) {
      return;
    }
    const networkToken = networkTokenBalances.find((token) => token.address === ChainController.getActiveNetworkTokenAddress());
    if (!networkToken) {
      return;
    }
    state16.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).eq(0)) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).gt(networkBalanceInUSD);
  },
  hasInsufficientGasFunds() {
    let isInsufficientNetworkTokenForGas = true;
    if (AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      isInsufficientNetworkTokenForGas = false;
    } else if (state16.networkBalanceInUSD) {
      isInsufficientNetworkTokenForGas = this.isInsufficientNetworkTokenForGas(state16.networkBalanceInUSD, state16.gasPriceInUSD);
    }
    return isInsufficientNetworkTokenForGas;
  },
  async sendNativeToken(params) {
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const to = params.receiverAddress;
    const address = AccountController.state.address;
    const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    const data = "0x";
    try {
      await ConnectionController.sendTransaction({
        chainNamespace: "eip155",
        to,
        address,
        data,
        value: value ?? BigInt(0),
        gasPrice: params.gasPrice
      });
      SnackController.showSuccess("Transaction started");
      EventsController.sendEvent({
        type: "track",
        event: "SEND_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol || "",
          amount: params.sendTokenAmount,
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
        }
      });
      this.resetSend();
    } catch (error) {
      console.error("SendController:sendERC20Token - failed to send native token", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          message: errorMessage,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol || "",
          amount: params.sendTokenAmount,
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
        }
      });
      SnackController.showError("Something went wrong");
    }
  },
  async sendERC20Token(params) {
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    try {
      if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {
        const tokenAddress = CoreHelperUtil.getPlainAddress(params.tokenAddress);
        await ConnectionController.writeContract({
          fromAddress: AccountController.state.address,
          tokenAddress,
          args: [params.receiverAddress, amount ?? BigInt(0)],
          method: "transfer",
          abi: ContractUtil.getERC20Abi(tokenAddress),
          chainNamespace: "eip155"
        });
        SnackController.showSuccess("Transaction started");
        this.resetSend();
      }
    } catch (error) {
      console.error("SendController:sendERC20Token - failed to send erc20 token", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          message: errorMessage,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol || "",
          amount: params.sendTokenAmount,
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
        }
      });
      SnackController.showError("Something went wrong");
    }
  },
  sendSolanaToken() {
    if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
      SnackController.showError("Please enter a valid amount and receiver address");
      return;
    }
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    ConnectionController.sendTransaction({
      chainNamespace: "solana",
      to: this.state.receiverAddress,
      value: this.state.sendTokenAmount
    }).then(() => {
      this.resetSend();
      AccountController.fetchTokenBalance();
    }).catch((error) => {
      SnackController.showError("Failed to send transaction. Please try again.");
      console.error("SendController:sendToken - failed to send solana transaction", error);
    });
  },
  resetSend() {
    state16.token = void 0;
    state16.sendTokenAmount = void 0;
    state16.receiverAddress = void 0;
    state16.receiverProfileImageUrl = void 0;
    state16.receiverProfileName = void 0;
    state16.loading = false;
    state16.tokenBalances = [];
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var accountState = {
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: [],
  user: void 0
};
var networkState = {
  caipNetwork: void 0,
  supportsAllNetworks: true,
  smartAccountEnabledNetworks: []
};
var state17 = proxy({
  chains: proxyMap(),
  activeCaipAddress: void 0,
  activeChain: void 0,
  activeCaipNetwork: void 0,
  noAdapters: false,
  universalAdapter: {
    networkControllerClient: void 0,
    connectionControllerClient: void 0
  },
  isSwitchingNamespace: false
});
var ChainController = {
  state: state17,
  subscribe(callback) {
    return subscribe(state17, () => {
      callback(state17);
    });
  },
  subscribeKey(key, callback) {
    return subscribeKey(state17, key, callback);
  },
  subscribeChainProp(property, callback, chain) {
    let prev = void 0;
    return subscribe(state17.chains, () => {
      const activeChain = chain || state17.activeChain;
      if (activeChain) {
        const nextValue = state17.chains.get(activeChain)?.[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  initialize(adapters, caipNetworks, clients) {
    const { chainId: activeChainId, namespace: activeNamespace } = StorageUtil.getActiveNetworkProps();
    const activeCaipNetwork = caipNetworks?.find((network) => network.id.toString() === activeChainId?.toString());
    const defaultAdapter = adapters.find((adapter) => adapter?.namespace === activeNamespace);
    const adapterToActivate = defaultAdapter || adapters?.[0];
    const namespaces = /* @__PURE__ */ new Set([...caipNetworks?.map((network) => network.chainNamespace) ?? []]);
    if (adapters?.length === 0 || !adapterToActivate) {
      state17.noAdapters = true;
    }
    if (!state17.noAdapters) {
      state17.activeChain = adapterToActivate?.namespace;
      state17.activeCaipNetwork = activeCaipNetwork;
      this.setChainNetworkData(adapterToActivate?.namespace, { caipNetwork: activeCaipNetwork });
      if (state17.activeChain) {
        PublicStateController.set({ activeChain: adapterToActivate?.namespace });
      }
    }
    namespaces.forEach((namespace) => {
      const namespaceNetworks = caipNetworks?.filter((network) => network.chainNamespace === namespace);
      ChainController.state.chains.set(namespace, {
        namespace,
        networkState: proxy({
          ...networkState,
          caipNetwork: namespaceNetworks?.[0]
        }),
        accountState: proxy(accountState),
        caipNetworks: namespaceNetworks ?? [],
        ...clients
      });
      this.setRequestedCaipNetworks(namespaceNetworks ?? [], namespace);
    });
  },
  removeAdapter(namespace) {
    if (state17.activeChain === namespace) {
      const nextAdapter = Array.from(state17.chains.entries()).find(([chainNamespace]) => chainNamespace !== namespace);
      if (nextAdapter) {
        const caipNetwork = nextAdapter[1]?.caipNetworks?.[0];
        if (caipNetwork) {
          this.setActiveCaipNetwork(caipNetwork);
        }
      }
    }
    state17.chains.delete(namespace);
  },
  addAdapter(adapter, { networkControllerClient, connectionControllerClient }, caipNetworks) {
    state17.chains.set(adapter.namespace, {
      namespace: adapter.namespace,
      networkState: {
        ...networkState,
        caipNetwork: caipNetworks[0]
      },
      accountState,
      caipNetworks,
      connectionControllerClient,
      networkControllerClient
    });
    this.setRequestedCaipNetworks(caipNetworks?.filter((caipNetwork) => caipNetwork.chainNamespace === adapter.namespace) ?? [], adapter.namespace);
  },
  addNetwork(network) {
    const chainAdapter = state17.chains.get(network.chainNamespace);
    if (chainAdapter) {
      const newNetworks = [...chainAdapter.caipNetworks || []];
      if (!chainAdapter.caipNetworks?.find((caipNetwork) => caipNetwork.id === network.id)) {
        newNetworks.push(network);
      }
      state17.chains.set(network.chainNamespace, { ...chainAdapter, caipNetworks: newNetworks });
      this.setRequestedCaipNetworks(newNetworks, network.chainNamespace);
    }
  },
  removeNetwork(namespace, networkId) {
    const chainAdapter = state17.chains.get(namespace);
    if (chainAdapter) {
      const isActiveNetwork = state17.activeCaipNetwork?.id === networkId;
      const newCaipNetworksOfAdapter = [
        ...chainAdapter.caipNetworks?.filter((network) => network.id !== networkId) || []
      ];
      if (isActiveNetwork && chainAdapter?.caipNetworks?.[0]) {
        this.setActiveCaipNetwork(chainAdapter.caipNetworks[0]);
      }
      state17.chains.set(namespace, { ...chainAdapter, caipNetworks: newCaipNetworksOfAdapter });
      this.setRequestedCaipNetworks(newCaipNetworksOfAdapter || [], namespace);
    }
  },
  setAdapterNetworkState(chain, props) {
    const chainAdapter = state17.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.networkState = {
        ...chainAdapter.networkState || networkState,
        ...props
      };
      state17.chains.set(chain, chainAdapter);
    }
  },
  setChainAccountData(chain, accountProps, _unknown = true) {
    if (!chain) {
      throw new Error("Chain is required to update chain account data");
    }
    const chainAdapter = state17.chains.get(chain);
    if (chainAdapter) {
      const newAccountState = { ...chainAdapter.accountState || accountState, ...accountProps };
      state17.chains.set(chain, { ...chainAdapter, accountState: newAccountState });
      if (state17.chains.size === 1 || state17.activeChain === chain) {
        if (accountProps.caipAddress) {
          state17.activeCaipAddress = accountProps.caipAddress;
        }
        AccountController.replaceState(newAccountState);
      }
    }
  },
  setChainNetworkData(chain, networkProps) {
    if (!chain) {
      return;
    }
    const chainAdapter = state17.chains.get(chain);
    if (chainAdapter) {
      const newNetworkState = { ...chainAdapter.networkState || networkState, ...networkProps };
      state17.chains.set(chain, { ...chainAdapter, networkState: newNetworkState });
    }
  },
  // eslint-disable-next-line max-params
  setAccountProp(prop, value, chain, replaceState = true) {
    this.setChainAccountData(chain, { [prop]: value }, replaceState);
    if (prop === "status" && value === "disconnected" && chain) {
      ConnectorController.removeConnectorId(chain);
    }
  },
  setActiveNamespace(chain) {
    state17.activeChain = chain;
    const newAdapter = chain ? state17.chains.get(chain) : void 0;
    const caipNetwork = newAdapter?.networkState?.caipNetwork;
    if (caipNetwork?.id && chain) {
      state17.activeCaipAddress = newAdapter?.accountState?.caipAddress;
      state17.activeCaipNetwork = caipNetwork;
      this.setChainNetworkData(chain, { caipNetwork });
      StorageUtil.setActiveCaipNetworkId(caipNetwork?.caipNetworkId);
      PublicStateController.set({
        activeChain: chain,
        selectedNetworkId: caipNetwork?.caipNetworkId
      });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    if (state17.activeChain !== caipNetwork.chainNamespace) {
      this.setIsSwitchingNamespace(true);
    }
    const newAdapter = state17.chains.get(caipNetwork.chainNamespace);
    state17.activeChain = caipNetwork.chainNamespace;
    state17.activeCaipNetwork = caipNetwork;
    this.setChainNetworkData(caipNetwork.chainNamespace, { caipNetwork });
    if (newAdapter?.accountState?.address) {
      state17.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${newAdapter?.accountState?.address}`;
    } else {
      state17.activeCaipAddress = void 0;
    }
    this.setAccountProp("caipAddress", state17.activeCaipAddress, caipNetwork.chainNamespace);
    if (newAdapter) {
      AccountController.replaceState(newAdapter.accountState);
    }
    SendController.resetSend();
    PublicStateController.set({
      activeChain: state17.activeChain,
      selectedNetworkId: state17.activeCaipNetwork?.caipNetworkId
    });
    StorageUtil.setActiveCaipNetworkId(caipNetwork.caipNetworkId);
    const isSupported = this.checkIfSupportedNetwork(caipNetwork.chainNamespace);
    if (!isSupported && OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && !ConnectionController.state.wcBasic) {
      this.showUnsupportedChainUI();
    }
  },
  addCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const chain = state17.chains.get(caipNetwork.chainNamespace);
    if (chain) {
      chain?.caipNetworks?.push(caipNetwork);
    }
  },
  async switchActiveNamespace(namespace) {
    if (!namespace) {
      return;
    }
    const isDifferentChain = namespace !== ChainController.state.activeChain;
    const caipNetworkOfNamespace = ChainController.getNetworkData(namespace)?.caipNetwork;
    const firstNetworkWithChain = ChainController.getCaipNetworkByNamespace(namespace, caipNetworkOfNamespace?.id);
    if (isDifferentChain && firstNetworkWithChain) {
      await ChainController.switchActiveNetwork(firstNetworkWithChain);
    }
  },
  async switchActiveNetwork(network) {
    const activeAdapter = ChainController.state.chains.get(ChainController.state.activeChain);
    const unsupportedNetwork = !activeAdapter?.caipNetworks?.some((caipNetwork) => caipNetwork.id === state17.activeCaipNetwork?.id);
    if (unsupportedNetwork) {
      RouterController.goBack();
    }
    const networkControllerClient = this.getNetworkControllerClient(network.chainNamespace);
    if (networkControllerClient) {
      await networkControllerClient.switchCaipNetwork(network);
      EventsController.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: network.caipNetworkId }
      });
    }
  },
  getNetworkControllerClient(chainNamespace) {
    const chain = chainNamespace || state17.activeChain;
    const chainAdapter = state17.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.networkControllerClient) {
      throw new Error("NetworkController client not set");
    }
    return chainAdapter.networkControllerClient;
  },
  getConnectionControllerClient(_chain) {
    const chain = _chain || state17.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get connection controller client");
    }
    const chainAdapter = state17.chains.get(chain);
    if (!chainAdapter?.connectionControllerClient) {
      throw new Error("ConnectionController client not set");
    }
    return chainAdapter.connectionControllerClient;
  },
  getAccountProp(key, _chain) {
    let chain = state17.activeChain;
    if (_chain) {
      chain = _chain;
    }
    if (!chain) {
      return void 0;
    }
    const chainAccountState = state17.chains.get(chain)?.accountState;
    if (!chainAccountState) {
      return void 0;
    }
    return chainAccountState[key];
  },
  getNetworkProp(key, namespace) {
    const chainNetworkState = state17.chains.get(namespace)?.networkState;
    if (!chainNetworkState) {
      return void 0;
    }
    return chainNetworkState[key];
  },
  getRequestedCaipNetworks(chainToFilter) {
    const adapter = state17.chains.get(chainToFilter);
    const { approvedCaipNetworkIds = [], requestedCaipNetworks = [] } = adapter?.networkState || {};
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    return sortedNetworks;
  },
  getAllRequestedCaipNetworks() {
    const requestedCaipNetworks = [];
    state17.chains.forEach((chainAdapter) => {
      const caipNetworks = this.getRequestedCaipNetworks(chainAdapter.namespace);
      requestedCaipNetworks.push(...caipNetworks);
    });
    return requestedCaipNetworks;
  },
  setRequestedCaipNetworks(requestedCaipNetworks, chain) {
    this.setAdapterNetworkState(chain, { requestedCaipNetworks });
  },
  getAllApprovedCaipNetworkIds() {
    const approvedCaipNetworkIds = [];
    state17.chains.forEach((chainAdapter) => {
      const approvedIds = this.getApprovedCaipNetworkIds(chainAdapter.namespace);
      approvedCaipNetworkIds.push(...approvedIds);
    });
    return approvedCaipNetworkIds;
  },
  getActiveCaipNetwork() {
    return state17.activeCaipNetwork;
  },
  getActiveCaipAddress() {
    return state17.activeCaipAddress;
  },
  getApprovedCaipNetworkIds(namespace) {
    const adapter = state17.chains.get(namespace);
    const approvedCaipNetworkIds = adapter?.networkState?.approvedCaipNetworkIds || [];
    return approvedCaipNetworkIds;
  },
  async setApprovedCaipNetworksData(namespace) {
    const networkControllerClient = this.getNetworkControllerClient();
    const data = await networkControllerClient?.getApprovedCaipNetworksData();
    this.setAdapterNetworkState(namespace, {
      approvedCaipNetworkIds: data?.approvedCaipNetworkIds,
      supportsAllNetworks: data?.supportsAllNetworks
    });
  },
  checkIfSupportedNetwork(namespace, caipNetwork) {
    const activeCaipNetwork = caipNetwork || state17.activeCaipNetwork;
    const requestedCaipNetworks = this.getRequestedCaipNetworks(namespace);
    if (!requestedCaipNetworks.length) {
      return true;
    }
    return requestedCaipNetworks?.some((network) => network.id === activeCaipNetwork?.id);
  },
  checkIfSupportedChainId(chainId) {
    if (!state17.activeChain) {
      return true;
    }
    const requestedCaipNetworks = this.getRequestedCaipNetworks(state17.activeChain);
    return requestedCaipNetworks?.some((network) => network.id === chainId);
  },
  // Smart Account Network Handlers
  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
    this.setAdapterNetworkState(chain, { smartAccountEnabledNetworks });
  },
  checkIfSmartAccountEnabled() {
    const networkId = NetworkUtil.caipNetworkIdToNumber(state17.activeCaipNetwork?.caipNetworkId);
    const activeChain = state17.activeChain;
    if (!activeChain || !networkId) {
      return false;
    }
    const smartAccountEnabledNetworks = this.getNetworkProp("smartAccountEnabledNetworks", activeChain);
    return Boolean(smartAccountEnabledNetworks?.includes(Number(networkId)));
  },
  getActiveNetworkTokenAddress() {
    const namespace = state17.activeCaipNetwork?.chainNamespace || "eip155";
    const chainId = state17.activeCaipNetwork?.id || 1;
    const address = ConstantsUtil2.NATIVE_TOKEN_ADDRESS[namespace];
    return `${namespace}:${chainId}:${address}`;
  },
  showUnsupportedChainUI() {
    ModalController.open({ view: "UnsupportedChain" });
  },
  checkIfNamesSupported() {
    const activeCaipNetwork = state17.activeCaipNetwork;
    return Boolean(activeCaipNetwork?.chainNamespace && ConstantsUtil2.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));
  },
  resetNetwork(namespace) {
    this.setAdapterNetworkState(namespace, {
      approvedCaipNetworkIds: void 0,
      supportsAllNetworks: true,
      smartAccountEnabledNetworks: []
    });
  },
  resetAccount(chain) {
    const chainToWrite = chain;
    if (!chainToWrite) {
      throw new Error("Chain is required to set account prop");
    }
    state17.activeCaipAddress = void 0;
    this.setChainAccountData(chainToWrite, {
      smartAccountDeployed: false,
      currentTab: 0,
      caipAddress: void 0,
      address: void 0,
      balance: void 0,
      balanceSymbol: void 0,
      profileName: void 0,
      profileImage: void 0,
      addressExplorerUrl: void 0,
      tokenBalance: [],
      connectedWalletInfo: void 0,
      preferredAccountType: void 0,
      socialProvider: void 0,
      socialWindow: void 0,
      farcasterUrl: void 0,
      allAccounts: [],
      user: void 0,
      status: "disconnected"
    });
    ConnectorController.removeConnectorId(chainToWrite);
  },
  async disconnect(namespace) {
    const chainsToDisconnect = getChainsToDisconnect(namespace);
    try {
      SendController.resetSend();
      const disconnectResults = await Promise.allSettled(chainsToDisconnect.map(async ([ns, adapter]) => {
        try {
          const { caipAddress } = this.getAccountData(ns) || {};
          if (caipAddress && adapter.connectionControllerClient?.disconnect) {
            await adapter.connectionControllerClient.disconnect(ns);
          }
          this.resetAccount(ns);
          this.resetNetwork(ns);
        } catch (error) {
          throw new Error(`Failed to disconnect chain ${ns}: ${error.message}`);
        }
      }));
      ConnectionController.resetWcConnection();
      const failures = disconnectResults.filter((result) => result.status === "rejected");
      if (failures.length > 0) {
        throw new Error(failures.map((f5) => f5.reason.message).join(", "));
      }
      StorageUtil.deleteConnectedSocialProvider();
      if (namespace) {
        ConnectorController.removeConnectorId(namespace);
      } else {
        ConnectorController.resetConnectorIds();
      }
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS",
        properties: {
          namespace: namespace || "all"
        }
      });
    } catch (error) {
      console.error(error.message || "Failed to disconnect chains");
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_ERROR",
        properties: {
          message: error.message || "Failed to disconnect chains"
        }
      });
    }
  },
  setIsSwitchingNamespace(isSwitchingNamespace) {
    state17.isSwitchingNamespace = isSwitchingNamespace;
  },
  getFirstCaipNetworkSupportsAuthConnector() {
    const availableChains = [];
    let firstCaipNetwork = void 0;
    state17.chains.forEach((chain) => {
      if (ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((ns) => ns === chain.namespace)) {
        if (chain.namespace) {
          availableChains.push(chain.namespace);
        }
      }
    });
    if (availableChains.length > 0) {
      const firstAvailableChain = availableChains[0];
      firstCaipNetwork = firstAvailableChain ? state17.chains.get(firstAvailableChain)?.caipNetworks?.[0] : void 0;
      return firstCaipNetwork;
    }
    return void 0;
  },
  getAccountData(chainNamespace) {
    if (!chainNamespace) {
      return AccountController.state;
    }
    return ChainController.state.chains.get(chainNamespace)?.accountState;
  },
  getNetworkData(chainNamespace) {
    const namespace = chainNamespace || state17.activeChain;
    if (!namespace) {
      return void 0;
    }
    return ChainController.state.chains.get(namespace)?.networkState;
  },
  getCaipNetworkByNamespace(chainNamespace, chainId) {
    if (!chainNamespace) {
      return void 0;
    }
    const chain = ChainController.state.chains.get(chainNamespace);
    const byChainId = chain?.caipNetworks?.find((network) => network.id === chainId);
    if (byChainId) {
      return byChainId;
    }
    return chain?.networkState?.caipNetwork || chain?.caipNetworks?.[0];
  },
  /**
   * Get the requested CaipNetwork IDs for a given namespace. If namespace is not provided, all requested CaipNetwork IDs will be returned
   * @param namespace - The namespace to get the requested CaipNetwork IDs for
   * @returns The requested CaipNetwork IDs
   */
  getRequestedCaipNetworkIds() {
    const namespace = ConnectorController.state.filterByNamespace;
    const chains = namespace ? [state17.chains.get(namespace)] : Array.from(state17.chains.values());
    return chains.flatMap((chain) => chain?.caipNetworks || []).map((caipNetwork) => caipNetwork.caipNetworkId);
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js
var baseUrl3 = CoreHelperUtil.getApiUrl();
var api2 = new FetchUtil({ baseUrl: baseUrl3, clientId: null });
var entries = "40";
var recommendedEntries = "4";
var imageCountToFetch = 20;
var state18 = proxy({
  promises: {},
  page: 1,
  count: 0,
  featured: [],
  allFeatured: [],
  recommended: [],
  allRecommended: [],
  wallets: [],
  search: [],
  isAnalyticsEnabled: false,
  excludedWallets: [],
  isFetchingRecommendedWallets: false
});
var ApiController = {
  state: state18,
  subscribeKey(key, callback) {
    return subscribeKey(state18, key, callback);
  },
  _getSdkProperties() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      projectId,
      st: sdkType || "appkit",
      sv: sdkVersion || "html-wagmi-4.2.2"
    };
  },
  _filterOutExtensions(wallets) {
    if (OptionsController.state.isUniversalProvider) {
      return wallets.filter((w) => Boolean(w.mobile_link || w.desktop_link || w.webapp_link));
    }
    return wallets;
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api2.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api2.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api2.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api2.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api2.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api2.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchCurrencyImage(countryCode) {
    const imageUrl = `${api2.baseUrl}/public/getCurrencyImage/${countryCode}`;
    const blob = await api2.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
  },
  async _fetchTokenImage(symbol) {
    const imageUrl = `${api2.baseUrl}/public/getTokenImage/${symbol}`;
    const blob = await api2.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
    AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
  },
  async fetchNetworkImages() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const ids = requestedCaipNetworks?.map(({ assets }) => assets?.imageId).filter(Boolean).filter((imageId) => !AssetUtil.getNetworkImageById(imageId));
    if (ids) {
      await Promise.allSettled(ids.map((id) => ApiController._fetchNetworkImage(id)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id) => ApiController._fetchConnectorImage(id)));
  },
  async fetchCurrencyImages(currencies = []) {
    await Promise.allSettled(currencies.map((currency) => ApiController._fetchCurrencyImage(currency)));
  },
  async fetchTokenImages(tokens = []) {
    await Promise.allSettled(tokens.map((token) => ApiController._fetchTokenImage(token)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds?.length) {
      const { data } = await api2.get({
        path: "/getWallets",
        params: {
          ...ApiController._getSdkProperties(),
          page: "1",
          entries: featuredWalletIds?.length ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds?.join(",")
        }
      });
      data.sort((a2, b2) => featuredWalletIds.indexOf(a2.id) - featuredWalletIds.indexOf(b2.id));
      const images = data.map((d2) => d2.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
      state18.featured = data;
      state18.allFeatured = data;
    }
  },
  async fetchRecommendedWallets() {
    try {
      state18.isFetchingRecommendedWallets = true;
      const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
      const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
      const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
      const { data, count } = await api2.get({
        path: "/getWallets",
        params: {
          ...ApiController._getSdkProperties(),
          page: "1",
          chains: caipNetworkIds,
          entries: recommendedEntries,
          include: includeWalletIds?.join(","),
          exclude: exclude?.join(",")
        }
      });
      const recent = StorageUtil.getRecentWallets();
      const recommendedImages = data.map((d2) => d2.image_id).filter(Boolean);
      const recentImages = recent.map((r2) => r2.image_id).filter(Boolean);
      await Promise.allSettled([...recommendedImages, ...recentImages].map((id) => ApiController._fetchWalletImage(id)));
      state18.recommended = data;
      state18.allRecommended = data;
      state18.count = count ?? 0;
    } catch {
    } finally {
      state18.isFetchingRecommendedWallets = false;
    }
  },
  async fetchWallets({ page }) {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
    const exclude = [
      ...state18.recommended.map(({ id }) => id),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data, count } = await api2.get({
      path: "/getWallets",
      params: {
        ...ApiController._getSdkProperties(),
        page: String(page),
        entries,
        chains: caipNetworkIds,
        include: includeWalletIds?.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data.slice(0, imageCountToFetch).map((w) => w.image_id).filter(Boolean);
    await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
    state18.wallets = CoreHelperUtil.uniqueBy([...state18.wallets, ...ApiController._filterOutExtensions(data)], "id");
    state18.count = count > state18.count ? count : state18.count;
    state18.page = page;
  },
  async initializeExcludedWallets({ ids }) {
    const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
    const { data } = await api2.get({
      path: "/getWallets",
      params: {
        ...ApiController._getSdkProperties(),
        page: "1",
        entries: String(ids.length),
        chains: caipNetworkIds,
        include: ids?.join(",")
      }
    });
    if (data) {
      data.forEach((wallet) => {
        if (wallet?.rdns) {
          state18.excludedWallets.push({ rdns: wallet.rdns, name: wallet.name });
        }
      });
    }
  },
  async searchWallet({ search, badge }) {
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state18.search = [];
    const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
    const { data } = await api2.get({
      path: "/getWallets",
      params: {
        ...ApiController._getSdkProperties(),
        page: "1",
        entries: "100",
        search: search?.trim(),
        badge_type: badge,
        chains: caipNetworkIds,
        include: includeWalletIds?.join(","),
        exclude: excludeWalletIds?.join(",")
      }
    });
    EventsController.sendEvent({
      type: "track",
      event: "SEARCH_WALLET",
      properties: { badge: badge ?? "", search: search ?? "" }
    });
    const images = data.map((w) => w.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id) => ApiController._fetchWalletImage(id)),
      CoreHelperUtil.wait(300)
    ]);
    state18.search = ApiController._filterOutExtensions(data);
  },
  initPromise(key, fetchFn) {
    const existingPromise = state18.promises[key];
    if (existingPromise) {
      return existingPromise;
    }
    return state18.promises[key] = fetchFn();
  },
  prefetch({ fetchConnectorImages = true, fetchFeaturedWallets = true, fetchRecommendedWallets = true, fetchNetworkImages = true } = {}) {
    const promises = [
      fetchConnectorImages && ApiController.initPromise("connectorImages", ApiController.fetchConnectorImages),
      fetchFeaturedWallets && ApiController.initPromise("featuredWallets", ApiController.fetchFeaturedWallets),
      fetchRecommendedWallets && ApiController.initPromise("recommendedWallets", ApiController.fetchRecommendedWallets),
      fetchNetworkImages && ApiController.initPromise("networkImages", ApiController.fetchNetworkImages)
    ].filter(Boolean);
    return Promise.allSettled(promises);
  },
  prefetchAnalyticsConfig() {
    if (OptionsController.state.features?.analytics) {
      ApiController.fetchAnalyticsConfig();
    }
  },
  async fetchAnalyticsConfig() {
    try {
      const { isAnalyticsEnabled } = await api2.get({
        path: "/getAnalyticsConfig",
        params: ApiController._getSdkProperties()
      });
      OptionsController.setFeatures({ analytics: isAnalyticsEnabled });
    } catch (error) {
      OptionsController.setFeatures({ analytics: false });
    }
  },
  setFilterByNamespace(namespace) {
    if (!namespace) {
      state18.featured = state18.allFeatured;
      state18.recommended = state18.allRecommended;
      return;
    }
    const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
    state18.featured = state18.allFeatured.filter((wallet) => wallet.chains?.some((chain) => caipNetworkIds.includes(chain)));
    state18.recommended = state18.allRecommended.filter((wallet) => wallet.chains?.some((chain) => caipNetworkIds.includes(chain)));
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OnRampController.js
var USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
var USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
var defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
var state19 = proxy(defaultState);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SwapController.js
var initialState = {
  // Loading states
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  // Error states
  fetchError: false,
  // Approval & Swap transaction states
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  // Input values
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  // Request values
  slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE,
  // Tokens
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  // Calculations
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
var state20 = proxy(initialState);

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TooltipController.js
var state21 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
var TooltipController = {
  state: state21,
  subscribe(callback) {
    return subscribe(state21, () => callback(state21));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state21, key, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state21.open = true;
    state21.message = message;
    state21.triggerRect = triggerRect;
    state21.variant = variant;
  },
  hide() {
    state21.open = false;
    state21.message = "";
    state21.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js
var SLIP44_MSB = 2147483648;
var EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js
var state22 = proxy({
  suggestions: [],
  loading: false
});
var EnsController = {
  state: state22,
  subscribe(callback) {
    return subscribe(state22, () => callback(state22));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state22, key, callback);
  },
  async resolveName(name) {
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e) {
      const error = e;
      throw new Error(error?.reasons?.[0]?.description || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(value) {
    try {
      state22.loading = true;
      state22.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(value);
      state22.suggestions = response.suggestions.map((suggestion) => ({
        ...suggestion,
        name: suggestion.name
      })) || [];
      return state22.suggestions;
    } catch (e) {
      const errorMessage = this.parseEnsApiError(e, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state22.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = ChainController.state.activeCaipNetwork;
      if (!network) {
        return [];
      }
      const cachedEns = StorageUtil.getEnsFromCacheForAddress(address);
      if (cachedEns) {
        return cachedEns;
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      StorageUtil.updateEnsCache({
        address,
        ens: response,
        timestamp: Date.now()
      });
      return response;
    } catch (e) {
      const errorMessage = this.parseEnsApiError(e, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    const network = ChainController.state.activeCaipNetwork;
    if (!network) {
      throw new Error("Network not found");
    }
    const address = AccountController.state.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    state22.loading = true;
    try {
      const message = JSON.stringify({
        name,
        attributes: {},
        // Unix timestamp
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        view: "RegisterAccountNameSuccess",
        goBack: false,
        replace: true,
        onCancel() {
          state22.loading = false;
        }
      });
      const signature = await ConnectionController.signMessage(message);
      const networkId = network.id;
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature,
        message
      });
      AccountController.setProfileName(name, network.chainNamespace);
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e) {
      const errorMessage = this.parseEnsApiError(e, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state22.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    const ensError = error;
    return ensError?.reasons?.[0]?.description || defaultError;
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsStateController.js
var state23 = proxy({
  isLegalCheckboxChecked: false
});

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeUtil.js
var themeTag = void 0;
var darkModeTag = void 0;
var lightModeTag = void 0;
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(themeVariables) {
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  }
}
function createRootStyles(themeVariables) {
  return {
    core: css`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${unsafeCSS(themeVariables?.["--w3m-color-mix-strength"] ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${unsafeCSS(themeVariables?.["--w3m-font-family"] || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${unsafeCSS(themeVariables?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${unsafeCSS(themeVariables?.["--w3m-border-radius-master"] || "4px")};
        --w3m-z-index: ${unsafeCSS(themeVariables?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: css`
      :root {
        --w3m-color-mix: ${unsafeCSS(themeVariables?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${unsafeCSS(getW3mThemeVariables(themeVariables, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${unsafeCSS(getW3mThemeVariables(themeVariables, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: css`
      :root {
        --w3m-color-mix: ${unsafeCSS(themeVariables?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${unsafeCSS(getW3mThemeVariables(themeVariables, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${unsafeCSS(getW3mThemeVariables(themeVariables, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
  };
}
var resetStyles = css`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
var elementStyles = css`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
var colorStyles = css`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-ui/dist/esm/src/utils/UiHelperUtil.js
var UiHelperUtil = {
  getSpacingStyles(spacing, index) {
    if (Array.isArray(spacing)) {
      return spacing[index] ? `var(--wui-spacing-${spacing[index]})` : void 0;
    } else if (typeof spacing === "string") {
      return `var(--wui-spacing-${spacing})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  getHostName(url) {
    try {
      const newUrl = new URL(url);
      return newUrl.hostname;
    } catch (error) {
      return "";
    }
  },
  getTruncateString({ string, charsStart, charsEnd, truncate }) {
    if (string.length <= charsStart + charsEnd) {
      return string;
    }
    if (truncate === "end") {
      return `${string.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string.substring(string.length - charsEnd)}`;
    }
    return `${string.substring(0, Math.floor(charsStart))}...${string.substring(string.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash = address.toLowerCase().replace(/^0x/iu, "").replace(/[^a-f0-9]/gu, "");
    const baseColor = hash.substring(0, 6).padEnd(6, "0");
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius?.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors = [];
    for (let i3 = 0; i3 < 5; i3 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i3);
      colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r2 = bigint >> 16 & 255;
    const g = bigint >> 8 & 255;
    const b2 = bigint & 255;
    return [r2, g, b2];
  },
  tintColor(rgb, tint) {
    const [r2, g, b2] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g + (255 - g) * tint);
    const tintedB = Math.round(b2 + (255 - b2) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character) {
    const regex = {
      number: /^[0-9]+$/u
    };
    return regex.number.test(character);
  },
  getColorTheme(theme) {
    if (theme) {
      return theme;
    } else if (typeof window !== "undefined" && window.matchMedia) {
      if (window.matchMedia("(prefers-color-scheme: dark)")?.matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  },
  splitBalance(input) {
    const parts = input.split(".");
    if (parts.length === 2) {
      return [parts[0], parts[1]];
    }
    return ["0", "00"];
  },
  roundNumber(number, threshold, fixed) {
    const roundedNumber = number.toString().length >= threshold ? Number(number).toFixed(fixed) : number;
    return roundedNumber;
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-ui/dist/esm/src/utils/WebComponentsUtil.js
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create2(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}

// node_modules/@walletconnect/solana-adapter/node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil3 = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  }
};

export {
  NetworkUtil,
  ConstantsUtil,
  ParseUtil,
  ConstantsUtil2,
  StorageUtil,
  CoreHelperUtil,
  AssetController,
  AssetUtil,
  OptionsController,
  AlertController,
  EventsController,
  ApiController,
  RouterController,
  ThemeController,
  ConnectorController,
  h,
  I,
  y,
  m,
  d,
  f,
  P,
  S,
  M,
  O,
  R,
  J,
  V,
  esm_default2 as esm_default,
  SnackController,
  SIWXUtil,
  ConnectionController,
  PublicStateController,
  ChainController,
  BlockchainApiController,
  AccountController,
  ModalController,
  TooltipController,
  EnsController,
  ConstantsUtil3,
  initializeTheming,
  setColorTheme,
  setThemeVariables,
  resetStyles,
  elementStyles,
  colorStyles,
  UiHelperUtil,
  customElement
};
//# sourceMappingURL=chunk-4UIXIBHK.js.map
